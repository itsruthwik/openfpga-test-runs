<!-- 
  Flagship Heterogeneous Architecture with Carry Chains for VTR 7.0.

  - 40 nm technology
  - General purpose logic block: 
    K = 6, N = 10, fracturable 6 LUTs (can operate as one 6-LUT or two 5-LUTs with 8 total FLE inputs (2 inputs of which are shared by the 5-LUTs) 
    with optionally registered outputs
    Each 5-LUT has an arithemtic mode that converts it to a single-bit adder with both inputs driven by 4-LUTs (both 4-LUTs share all 4 inputs)
    Carry chain links to vertically adjacent logic blocks
  - Memory size 32 Kbits, memory aspect ratios vary from a data width of 1 to data width of 64.  
    Height = 6, found on every (8n+2)th column
  - Multiplier modes: one 36x36, two 18x18, each 18x18 can also operate as two 9x9.  
    Height = 4, found on every (8n+6)th column
  - Routing architecture: L = 4, fc_in = 0.15, Fc_out = 0.1

  Details on Modelling:

  The electrical design of the architecture described here is NOT from an 
  optimized, SPICED architecture.  Instead, we attempt to create a reasonable 
  architecture file by using an existing commercial FPGA to approximate the area, 
  delay, and power of the underlying components. This is combined with a reasonable 40 nm 
  model of wiring and circuit design for low-level routing components, where available.
  The resulting architecture has delays that roughly match a commercial 40 nm FPGA, but also 
  has wiring electrical parameters that allow the wire lengths and switch patterns to be 
  modified and you will still get reasonable delay results for the new architecture.
  The following describes, in detail, how we obtained the various electrical values for this 
  architecture.

  Rmin for nmos and pmos, routing buffer sizes, and I/O pad delays are from the ifar 
  architecture created by Ian Kuon: K06 N10 45nm fc 0.15 area-delay optimized architecture. 
  (n10k06l04.fc15.area1delay1.cmos45nm.bptm.cmos45nm.xml)      
  This routing architecture was optimized for 45 nm, and we have scaled it linearly to 40 nm to 
  match the overall target (a 40 nm FPGA).

  We obtain delay numbers by measuring delays of routing, soft logic blocks, 
  memories, and multipliers from test circuits on a Stratix IV GX device 
  (EP4SGX230DF29C2X, i.e. fastest speed grade). For routing, we took the average delay of H4 and V4 
  wires.  Rmetal and Cmetal values for the routing wires were obtained from work done by Charles 
  Chiasson. We use a 96 nm half-pitch (corresponding to mid-level metal stack 40 nm routing) and 
  take the R and C data from the ITRS roadmap.  

  For the general purpose logic block, we assume that the area and delays of the Stratix IV 
  crossbar is close enough to the crossbar modelled here.  
  Stratix IV uses 52 inputs and 20 feedback lines, but only a half-populated crossbar, leading to 
  36:1 multiplexers.  We match these parameters in this architecture.

  For LUTs, we include LUT 
  delays measured from Stratix IV which is dependant on the input used (ie. some 
  LUT inputs are faster than others).  The CAD tools at the time of VTR 7 does 
  not consider differences in LUT input delays.

  Adder delays obtained as approximate values from a Stratix IV EP4SE230F29C3 device.  
  Delay obtained by compiling a 256 bit adder (registered inputs and outputs, 
  all pins except clock virtual) then measuring the delays in chip-planner, 
  sumout delay = 0.271ns to 0.348 ns, intra-block carry delay = 0.011 ns, 
  inter-block carry delay = 0.327 ns.  Given this data, I will approximate 
  sumout 0.3 ns, intra-block carry-delay = 0.01 ns, and 
  inter-block carry-delay = 0.16 ns (since Altera inter-block carry delay has 
  overhead that we don't have, I'll approximate the delay of a simpler chain at 
  one half what they have.  This is very rough, anything from 0.01ns to 0.327ns 
  can be justified).

  Logic block area numbers obtained by scaling overall tile area of a 65nm 
  Stratix III device, (as given in Wong, Betz and Rose, FPGA 2011) to 40 nm, then subtracting out 
  routing area at a channel width of 300. We use a channel width of 300 because it can route 
  all the VTR 6.0 benchmark circuits with an approximately 20% safety margin, and is also close to the
  total channel width of Stratix IV. Hence this channel width is close to the commercial practice of
  choosing a width that provides high routability. The architecture can be routed at different channel
  widths, but we estimate the tile size and hence the physical length of routing wires assuming
  a channel width of 300.

  Sanity checks employed:
    1.  We confirmed the routing buffer delay is ~1/3rd of total routing delay at L = 4. This matches 
        common electrical design.


  Authors: Jason Luu, Jeff Goeders, Vaughn Betz
-->
<architecture>
  <!-- 
       ODIN II specific config begins 
       Describes the types of user-specified netlist blocks (in blif, this corresponds to 
       ".model [type_of_block]") that this architecture supports.

       Note: Basic LUTs, I/Os, and flip-flops are not included here as there are 
       already special structures in blif (.names, .input, .output, and .latch) 
       that describe them.
  -->
  <models>
    <model name="adder">
      <input_ports>
        <port name="a" combinational_sink_ports="sumout cout"/>
        <port name="b" combinational_sink_ports="sumout cout"/>
        <port name="cin" combinational_sink_ports="sumout cout"/>
      </input_ports>
      <output_ports>
        <port name="cout"/>
        <port name="sumout"/>
      </output_ports>
    </model>
    <!-- A virtual model for I/O to be used in the physical mode of io block -->
    <model name="io">
      <input_ports>
        <port name="outpad"/>
      </input_ports>
      <output_ports>
        <port name="inpad"/>
      </output_ports>
    </model>
    <!-- A virtual model for I/O to be used in the physical mode of io block -->
    <model name="frac_lut6">
      <input_ports>
        <port name="in"/>
      </input_ports>
      <output_ports>
        <port name="lut4_out"/>
        <port name="lut5_out"/>
        <port name="lut6_out"/>
      </output_ports>
    </model>
    <model name="single_port_ram">
      <input_ports>
        <port name="we" clock="clk" combinational_sink_ports="out"/>
        <!-- control -->
        <port name="addr" clock="clk" combinational_sink_ports="out"/>
        <!-- address lines -->
        <port name="data" clock="clk" combinational_sink_ports="out"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="clk" is_clock="1"/>
        <!-- memories are often clocked -->
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
      </output_ports>
    </model>
    <model name="dual_port_ram">
      <input_ports>
        <port name="we1" clock="clk" combinational_sink_ports="out1"/>
        <!-- write enable -->
        <port name="we2" clock="clk" combinational_sink_ports="out2"/>
        <!-- write enable -->
        <port name="addr1" clock="clk" combinational_sink_ports="out1"/>
        <!-- address lines -->
        <port name="addr2" clock="clk" combinational_sink_ports="out2"/>
        <!-- address lines -->
        <port name="data1" clock="clk" combinational_sink_ports="out1"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="data2" clock="clk" combinational_sink_ports="out2"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="clk" is_clock="1"/>
        <!-- memories are often clocked -->
      </input_ports>
      <output_ports>
        <port name="out1" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
        <port name="out2" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
      </output_ports>
    </model>
    <!-- <model name="mult_36">
      <input_ports>
        <port name="A" combinational_sink_ports="Y"/>
        <port name="B" combinational_sink_ports="Y"/>
      </input_ports>
      <output_ports>
        <port name="Y"/>
      </output_ports>
    </model> -->

    <!-- Used inside DSPs. 
         Fixed point multiplication.
         ODIN infers these when * sign appears in RTL. -->
    <model name="multiply">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>
    <!-- Used inside DSPs. 
         Floating point multiplication. -->
    <model name="mult_fp_16">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>   
    <model name="mult_fp_32">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>   
    <model name="mult_fp_clk_16">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <model name="mult_fp_clk_32">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <!-- Multi bit floating point adder inside DSP slices -->
    <model name="addition_fp_16">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>
    <model name="addition_fp_32">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>
    <model name="addition_fp_clk_16">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <model name="addition_fp_clk_32">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="int_sop_2">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="by" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="mult_add_int_27x27">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="scanin" clock="clk" combinational_sink_ports="result scanout chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
        <port name="scanout"/>
      </output_ports>
    </model>
    <model name="mult_add_int_18x19">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="scanin" clock="clk" combinational_sink_ports="result scanout chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
        <port name="scanout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="int_sop_4">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="by" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="int_sop_accum_4">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="by" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!-- Floating point MAC inside DSP slices -->
    <model name="mac_fp_16">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="out"/>
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <model name="mac_fp_32">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="out"/>
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <!-- Fixed point MAC inside DSP slices -->
    <model name="mac_int_27x27">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="out"/>
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <model name="mac_int_18x19">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="out"/>
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <model name="mac_int_9x9">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="out"/>
        <port name="a" clock="clk" combinational_sink_ports="out"/>
        <port name="b" clock="clk" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="fp16_mult_add">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model> 
    <!--A mode in DSP slice-->
    <model name="fp16_sop2_mult">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model> 
    <!--A mode in DSP slice-->
    <model name="fp16_sop2_accum">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_b" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="fp16_mult_fp32_add">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>    
    <!--A mode in DSP slice-->
    <model name="fp16_mult_fp32_accum">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="top_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bot_b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="fp32_mult_add">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model> 
    <!--A mode in DSP slice-->
    <model name="fp32_mult_then_add">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="mode_sigs" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="a" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="b" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="fp32_in" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model> 
    <!-- A virtual model for flip-flops -->
    <model name="dff">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffsr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="R" clock="C"/>
        <port name="S" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="R" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffs">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="S" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffrn">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="RN" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffsn">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="SN" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="axi_hbm_physical">
     <input_ports>
        <port name="clk"         is_clock="1"/>
        <port name="rst"         clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="hbm_inpad"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tvalid"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid"        clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready"    clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
     </input_ports>
     <output_ports>
        <port name="hbm_outpad"     clock="clk"/>
        <port name="axis_in_tready"     clock="clk"/>
        <port name="axis_out_tvalid"    clock="clk"/>
        <port name="axis_out_tdata"     clock="clk"/>
        <port name="axis_out_tlast"     clock="clk"/>
        <port name="axis_out_tid"       clock="clk"/>
        <port name="axis_out_tdest"     clock="clk"/>
     </output_ports>
    </model>
    <model name="axi_eth_physical">
     <input_ports>
        <port name="clk"         is_clock="1"/>
        <port name="rst"         clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="eth_inpad"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tvalid"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid"        clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready"    clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
     </input_ports>
     <output_ports>
        <port name="eth_outpad"     clock="clk"/>
        <port name="axis_in_tready"     clock="clk"/>
        <port name="axis_out_tvalid"    clock="clk"/>
        <port name="axis_out_tdata"     clock="clk"/>
        <port name="axis_out_tlast"     clock="clk"/>
        <port name="axis_out_tid"       clock="clk"/>
        <port name="axis_out_tdest"     clock="clk"/>
     </output_ports>
    </model>
    <model name="axi_hbm">
     <input_ports>
        <port name="clk"         is_clock="1"/>
        <port name="rst"         clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tvalid"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid"        clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready"    clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
     </input_ports>
     <output_ports>
        <port name="axis_in_tready"     clock="clk"/>
        <port name="axis_out_tvalid"    clock="clk"/>
        <port name="axis_out_tdata"     clock="clk"/>
        <port name="axis_out_tlast"     clock="clk"/>
        <port name="axis_out_tid"       clock="clk"/>
        <port name="axis_out_tdest"     clock="clk"/>
     </output_ports>
    </model>
    <model name="axi_eth">
     <input_ports>
        <port name="clk"         is_clock="1"/>
        <port name="rst"         clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tvalid"     clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid"        clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest"      clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready"    clock="clk"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
     </input_ports>
     <output_ports>
        <port name="axis_in_tready"     clock="clk"/>
        <port name="axis_out_tvalid"    clock="clk"/>
        <port name="axis_out_tdata"     clock="clk"/>
        <port name="axis_out_tlast"     clock="clk"/>
        <port name="axis_out_tid"       clock="clk"/>
        <port name="axis_out_tdest"     clock="clk"/>
     </output_ports>
    </model>
    <model name="router_wrap_physical">
      <input_ports>
        <port name="clk_usr" is_clock="1"/>
        <port name="clk_noc" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="rst_n" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="data_in" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="dest_in" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="is_tail_in" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="send_in" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="credit_in" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        
        <port name="axis_in_tvalid" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="router_address" clock="clk_usr"  combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
      </input_ports>
      <output_ports>
        <port name="credit_out" clock="clk_usr"/>
        <port name="data_out" clock="clk_usr"/>
        <port name="dest_out" clock="clk_usr"/>
        <port name="is_tail_out" clock="clk_usr"/>
        <port name="send_out" clock="clk_usr"/>
        
        <port name="axis_in_tready" clock="clk_usr"/>
        <port name="axis_out_tvalid" clock="clk_usr"/>
        <port name="axis_out_tdata" clock="clk_usr"/>
        <port name="axis_out_tlast" clock="clk_usr"/>
        <port name="axis_out_tid" clock="clk_usr"/>
        <port name="axis_out_tdest" clock="clk_usr"/>
      </output_ports>
    </model>
    <model name="router_wrap">
      <input_ports>
        <port name="clk_usr" is_clock="1"/>
        <port name="clk_noc" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="rst_n" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        
        <port name="axis_in_tvalid" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdata" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tlast" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tid" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_in_tdest" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="axis_out_tready" clock="clk_usr"   combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
        <port name="router_address" clock="clk_usr"  combinational_sink_ports="axis_in_tready axis_out_tvalid axis_out_tdata axis_out_tlast axis_out_tid axis_out_tdest"/>
      </input_ports>
      <output_ports>        
        <port name="axis_in_tready" clock="clk_usr"/>
        <port name="axis_out_tvalid" clock="clk_usr"/>
        <port name="axis_out_tdata" clock="clk_usr"/>
        <port name="axis_out_tlast" clock="clk_usr"/>
        <port name="axis_out_tid" clock="clk_usr"/>
        <port name="axis_out_tdest" clock="clk_usr"/>
      </output_ports>
    </model>
    </models>
  <tiles>
    <tile name="io" area="0">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io"/>
        </equivalent_sites>          
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad</loc>
          <loc side="top">io.outpad io.inpad</loc>
          <loc side="right">io.outpad io.inpad</loc>
          <loc side="bottom">io.outpad io.inpad</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb" area="53894">
      <sub_tile name="clb">
        <equivalent_sites>
          <site pb_type="clb"/>
        </equivalent_sites>
        <input name="I" num_pins="40" equivalent="full"/>
        <input name="cin" num_pins="1"/>
        <input name="set" num_pins="1" is_non_clock_global="true"/>
        <input name="reset" num_pins="1" is_non_clock_global="true"/>
        <output name="O" num_pins="20" equivalent="none"/>
        <output name="cout" num_pins="1"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
          <fc_override port_name="clk" fc_type="frac" fc_val="0"/>
          <fc_override port_name="set" fc_type="frac" fc_val="0"/>
          <fc_override port_name="reset" fc_type="frac" fc_val="0"/>
        </fc>
        <!--  Highly recommand to customize pin location when direct connection is used!!! -->
        <!--pinlocations pattern="spread"/-->
        <pinlocations pattern="custom">
          <loc side="left">clb.clk clb.reset clb.set clb.O[14:10] clb.I[39:30]</loc>
          <loc side="top">clb.cin clb.O[9:5] clb.I[19:10]</loc>
          <loc side="right">clb.O[4:0] clb.I[9:0]</loc>
          <loc side="bottom">clb.cout clb.O[19:15] clb.I[29:20]</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="memory" height="3" width="1" area="137668">
      <sub_tile name="memory">
        <equivalent_sites>
          <site pb_type="memory" pin_mapping="direct"/>
        </equivalent_sites>
      <input name="addr1" num_pins="11"/>
      <input name="addr2" num_pins="11"/>
      <input name="data" num_pins="40"/>
      <input name="we1" num_pins="1"/>
      <input name="we2" num_pins="1"/>
      <output name="out" num_pins="40"/>
      <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <fc_override fc_type="frac" fc_val="0" port_name="clk"/>
        </fc>  
        <!-- <pinlocations pattern="spread"/> -->
        <pinlocations pattern="custom">
          <loc side="left" yoffset="0">memory.out[0:4] memory.data[0:4] memory.addr1[0:2]</loc>
          <loc side="left" yoffset="1">memory.out[5:9] memory.data[5:9] memory.addr1[3:5]</loc>
          <loc side="left" yoffset="2">memory.out[10:14] memory.data[10:14] memory.addr1[6:8]</loc>
          <loc side="top" yoffset="2">memory.clk memory.out[15:19] memory.data[15:19] memory.addr1[9:10] memory.we1</loc>

          <loc side="right" yoffset="0">memory.out[20:24] memory.data[20:24] memory.addr2[0:2]</loc>
          <loc side="right" yoffset="1">memory.out[25:29] memory.data[25:29] memory.addr2[3:5]</loc>
          <loc side="right" yoffset="2">memory.out[30:34] memory.data[30:34] memory.addr2[6:8]</loc>
          <loc side="bottom">memory.out[35:39] memory.data[35:39] memory.addr2[9:10] memory.we2</loc>         
        </pinlocations> 
      </sub_tile>
    </tile>
    <tile name="dsp_top" height="4" width="1" area="253779">
      <sub_tile name="dsp_top">
        <equivalent_sites>
          <site pb_type="dsp_top" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="reset" num_pins="1" is_non_clock_global="true"/>
        <input name="dsp_I1" num_pins="64" />
        <input name="dsp_I2" num_pins="64" />
        <input name="chainin" num_pins="64"/>
        <input name="scanin" num_pins="27"/>
        <output name="result" num_pins="74"/>
        <output name="chainout" num_pins="64"/>
        <output name="scanout" num_pins="27"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <!-- clock pins and chain ports do not connect to local routing -->
          <fc_override port_name="clk" fc_type="frac" fc_val="0"/>
          <fc_override port_name="chainin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="chainout" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanout" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
        	  <loc side="left" yoffset="0">dsp_top.dsp_I1[31:0]</loc>
	          <loc side="right" yoffset="1">dsp_top.dsp_I1[63:32]</loc>
	          <loc side="left" yoffset="2">dsp_top.dsp_I2[31:0]</loc>
	          <loc side="right" yoffset="3">dsp_top.dsp_I2[63:32]</loc>
	          <loc side="top">dsp_top.chainin dsp_top.scanin</loc>
	          <loc side="bottom">dsp_top.chainout dsp_top.scanout</loc>
	          <loc side="right" yoffset="0">dsp_top.result[17:0] dsp_top.clk</loc>
	          <loc side="left" yoffset="1">dsp_top.result[36:18]</loc>
	          <loc side="right" yoffset="2">dsp_top.result[55:37] </loc>
	          <loc side="left" yoffset="3">dsp_top.result[73:56] dsp_top.reset</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="axi_hbm_tile" height="1" width="20">
      <sub_tile name="axi_hbm_tile">
        <equivalent_sites>
           <site pb_type="axi_hbm_tile"/>
        </equivalent_sites>
        <clock name="clk" num_pins="1"/>
        <input name="rst" num_pins="1" is_non_clock_global="true"/>
        
        <output name="hbm_outpad" num_pins="128"/>
        <input name="hbm_inpad" num_pins="128"/>

        <input name="axis_in_tvalid" num_pins="1"/>
        <input name="axis_in_tdata" num_pins="128"/>
        <input name="axis_in_tlast" num_pins="1"/>
        <input name="axis_in_tid" num_pins="2"/>
        <input name="axis_in_tdest" num_pins="4"/>
        <input name="axis_out_tready" num_pins="1"/>

        <output name="axis_in_tready" num_pins="1"/>
        <output name="axis_out_tvalid" num_pins="1"/>
        <output name="axis_out_tdata" num_pins="128"/>
        <output name="axis_out_tlast" num_pins="1"/>
        <output name="axis_out_tid" num_pins="2"/>
        <output name="axis_out_tdest" num_pins="4"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
           <pinlocations pattern="custom">
              <loc side="top" xoffset="0">axi_hbm_tile.axis_out_tdata[0:6] axi_hbm_tile.axis_in_tdata[0:6]</loc>
              <loc side="top" xoffset="1">axi_hbm_tile.axis_out_tdata[7:13] axi_hbm_tile.axis_in_tdata[7:13]</loc>
              <loc side="top" xoffset="2">axi_hbm_tile.axis_out_tdata[14:20] axi_hbm_tile.axis_in_tdata[14:20]</loc>
              <loc side="top" xoffset="3">axi_hbm_tile.axis_out_tdata[21:27] axi_hbm_tile.axis_in_tdata[21:27]</loc>
              <loc side="top" xoffset="4">axi_hbm_tile.axis_out_tdata[28:34] axi_hbm_tile.axis_in_tdata[28:34]</loc>
              <loc side="top" xoffset="5">axi_hbm_tile.axis_out_tdata[35:41] axi_hbm_tile.axis_in_tdata[35:41]</loc>
              <loc side="top" xoffset="6">axi_hbm_tile.axis_out_tdata[42:48] axi_hbm_tile.axis_in_tdata[42:48]</loc>
              <loc side="top" xoffset="7">axi_hbm_tile.axis_out_tdata[49:55] axi_hbm_tile.axis_in_tdata[49:55]</loc>
              <loc side="top" xoffset="8">axi_hbm_tile.axis_out_tdata[56:62] axi_hbm_tile.axis_in_tdata[56:62]</loc>
              <loc side="top" xoffset="9">axi_hbm_tile.axis_out_tdata[63:69] axi_hbm_tile.axis_in_tdata[63:69]</loc>
              <loc side="top" xoffset="10">axi_hbm_tile.axis_out_tdata[70:76] axi_hbm_tile.axis_in_tdata[70:76]</loc>
              <loc side="top" xoffset="11">axi_hbm_tile.axis_out_tdata[77:83] axi_hbm_tile.axis_in_tdata[77:83]</loc>
              <loc side="top" xoffset="12">axi_hbm_tile.axis_out_tdata[84:90] axi_hbm_tile.axis_in_tdata[84:90]</loc>
              <loc side="top" xoffset="13">axi_hbm_tile.axis_out_tdata[91:97] axi_hbm_tile.axis_in_tdata[91:97]</loc>
              <loc side="top" xoffset="14">axi_hbm_tile.axis_out_tdata[98:104] axi_hbm_tile.axis_in_tdata[98:104]</loc>
              <loc side="top" xoffset="15">axi_hbm_tile.axis_out_tdata[105:111] axi_hbm_tile.axis_in_tdata[105:111]</loc>
              <loc side="top" xoffset="16">axi_hbm_tile.axis_out_tdata[112:118] axi_hbm_tile.axis_in_tdata[112:118]</loc>
              <loc side="top" xoffset="17">axi_hbm_tile.axis_out_tdata[119:125] axi_hbm_tile.axis_in_tdata[119:125]</loc>
              <loc side="top" xoffset="18">axi_hbm_tile.clk axi_hbm_tile.rst axi_hbm_tile.axis_out_tdata[126:127] axi_hbm_tile.axis_in_tdata[126:127] axi_hbm_tile.axis_out_tlast axi_hbm_tile.axis_out_tid[0:1] axi_hbm_tile.axis_in_tlast axi_hbm_tile.axis_in_tid[0:1]</loc>
              <loc side="top" xoffset="19">axi_hbm_tile.axis_out_tdest[0:3] axi_hbm_tile.axis_out_tready axi_hbm_tile.axis_out_tvalid axi_hbm_tile.axis_in_tdest[0:4] axi_hbm_tile.axis_in_tready axi_hbm_tile.axis_in_tvalid</loc>

              <loc side="bottom" xoffset="0"> axi_hbm_tile.hbm_inpad[0:6]       axi_hbm_tile.hbm_outpad[0:6]</loc>
              <loc side="bottom" xoffset="1"> axi_hbm_tile.hbm_inpad[7:13]      axi_hbm_tile.hbm_outpad[7:13]</loc>
              <loc side="bottom" xoffset="2"> axi_hbm_tile.hbm_inpad[14:20]     axi_hbm_tile.hbm_outpad[14:20]</loc>
              <loc side="bottom" xoffset="3"> axi_hbm_tile.hbm_inpad[21:27]     axi_hbm_tile.hbm_outpad[21:27]</loc>
              <loc side="bottom" xoffset="4"> axi_hbm_tile.hbm_inpad[28:34]     axi_hbm_tile.hbm_outpad[28:34]</loc>
              <loc side="bottom" xoffset="5"> axi_hbm_tile.hbm_inpad[35:41]     axi_hbm_tile.hbm_outpad[35:41]</loc>
              <loc side="bottom" xoffset="6"> axi_hbm_tile.hbm_inpad[42:48]     axi_hbm_tile.hbm_outpad[42:48]</loc>
              <loc side="bottom" xoffset="7"> axi_hbm_tile.hbm_inpad[49:55]     axi_hbm_tile.hbm_outpad[49:55]</loc>
              <loc side="bottom" xoffset="8"> axi_hbm_tile.hbm_inpad[56:62]     axi_hbm_tile.hbm_outpad[56:62]</loc>
              <loc side="bottom" xoffset="9"> axi_hbm_tile.hbm_inpad[63:69]     axi_hbm_tile.hbm_outpad[63:69]</loc>
              <loc side="bottom" xoffset="10">axi_hbm_tile.hbm_inpad[70:76]     axi_hbm_tile.hbm_outpad[70:76]</loc>
              <loc side="bottom" xoffset="11">axi_hbm_tile.hbm_inpad[77:83]     axi_hbm_tile.hbm_outpad[77:83]</loc>
              <loc side="bottom" xoffset="12">axi_hbm_tile.hbm_inpad[84:90]     axi_hbm_tile.hbm_outpad[84:90]</loc>
              <loc side="bottom" xoffset="13">axi_hbm_tile.hbm_inpad[91:97]     axi_hbm_tile.hbm_outpad[91:97]</loc>
              <loc side="bottom" xoffset="14">axi_hbm_tile.hbm_inpad[98:104]    axi_hbm_tile.hbm_outpad[98:104]</loc>
              <loc side="bottom" xoffset="15">axi_hbm_tile.hbm_inpad[105:111]   axi_hbm_tile.hbm_outpad[105:111]</loc>
              <loc side="bottom" xoffset="16">axi_hbm_tile.hbm_inpad[112:118]   axi_hbm_tile.hbm_outpad[112:118]</loc>
              <loc side="bottom" xoffset="17">axi_hbm_tile.hbm_inpad[119:125]   axi_hbm_tile.hbm_outpad[119:125]</loc>
              <loc side="bottom" xoffset="18">axi_hbm_tile.hbm_inpad[126:127]   axi_hbm_tile.hbm_outpad[126:127]</loc> 
            </pinlocations>
        <switchblock_locations pattern="none"/>
      </sub_tile>
    </tile>
    <tile name="axi_eth_tile" height="1" width="20">
      <sub_tile name="axi_eth_tile">
        <equivalent_sites>
           <site pb_type="axi_eth_tile"/>
        </equivalent_sites>
        <clock name="clk" num_pins="1"/>
        <input name="rst" num_pins="1" is_non_clock_global="true"/>

        <output name="eth_outpad" num_pins="128"/>
        <input name="eth_inpad" num_pins="128"/>

        <input name="axis_in_tvalid" num_pins="1"/>
        <input name="axis_in_tdata" num_pins="128"/>
        <input name="axis_in_tlast" num_pins="1"/>
        <input name="axis_in_tid" num_pins="2"/>
        <input name="axis_in_tdest" num_pins="4"/>
        <input name="axis_out_tready" num_pins="1"/>

        <output name="axis_in_tready" num_pins="1"/>
        <output name="axis_out_tvalid" num_pins="1"/>
        <output name="axis_out_tdata" num_pins="128"/>
        <output name="axis_out_tlast" num_pins="1"/>
        <output name="axis_out_tid" num_pins="2"/>
        <output name="axis_out_tdest" num_pins="4"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
           <pinlocations pattern="custom">
              <loc side="top" xoffset="0">axi_eth_tile.axis_out_tdata[0:6] axi_eth_tile.axis_in_tdata[0:6]</loc>
              <loc side="top" xoffset="1">axi_eth_tile.axis_out_tdata[7:13] axi_eth_tile.axis_in_tdata[7:13]</loc>
              <loc side="top" xoffset="2">axi_eth_tile.axis_out_tdata[14:20] axi_eth_tile.axis_in_tdata[14:20]</loc>
              <loc side="top" xoffset="3">axi_eth_tile.axis_out_tdata[21:27] axi_eth_tile.axis_in_tdata[21:27]</loc>
              <loc side="top" xoffset="4">axi_eth_tile.axis_out_tdata[28:34] axi_eth_tile.axis_in_tdata[28:34]</loc>
              <loc side="top" xoffset="5">axi_eth_tile.axis_out_tdata[35:41] axi_eth_tile.axis_in_tdata[35:41]</loc>
              <loc side="top" xoffset="6">axi_eth_tile.axis_out_tdata[42:48] axi_eth_tile.axis_in_tdata[42:48]</loc>
              <loc side="top" xoffset="7">axi_eth_tile.axis_out_tdata[49:55] axi_eth_tile.axis_in_tdata[49:55]</loc>
              <loc side="top" xoffset="8">axi_eth_tile.axis_out_tdata[56:62] axi_eth_tile.axis_in_tdata[56:62]</loc>
              <loc side="top" xoffset="9">axi_eth_tile.axis_out_tdata[63:69] axi_eth_tile.axis_in_tdata[63:69]</loc>
              <loc side="top" xoffset="10">axi_eth_tile.axis_out_tdata[70:76] axi_eth_tile.axis_in_tdata[70:76]</loc>
              <loc side="top" xoffset="11">axi_eth_tile.axis_out_tdata[77:83] axi_eth_tile.axis_in_tdata[77:83]</loc>
              <loc side="top" xoffset="12">axi_eth_tile.axis_out_tdata[84:90] axi_eth_tile.axis_in_tdata[84:90]</loc>
              <loc side="top" xoffset="13">axi_eth_tile.axis_out_tdata[91:97] axi_eth_tile.axis_in_tdata[91:97]</loc>
              <loc side="top" xoffset="14">axi_eth_tile.axis_out_tdata[98:104] axi_eth_tile.axis_in_tdata[98:104]</loc>
              <loc side="top" xoffset="15">axi_eth_tile.axis_out_tdata[105:111] axi_eth_tile.axis_in_tdata[105:111]</loc>
              <loc side="top" xoffset="16">axi_eth_tile.axis_out_tdata[112:118] axi_eth_tile.axis_in_tdata[112:118]</loc>
              <loc side="top" xoffset="17">axi_eth_tile.axis_out_tdata[119:125] axi_eth_tile.axis_in_tdata[119:125]</loc>
              <loc side="top" xoffset="18">axi_eth_tile.clk axi_eth_tile.rst axi_eth_tile.axis_out_tdata[126:127] axi_eth_tile.axis_in_tdata[126:127] axi_eth_tile.axis_out_tlast axi_eth_tile.axis_out_tid[0:1] axi_eth_tile.axis_in_tlast axi_eth_tile.axis_in_tid[0:1]</loc>
              <loc side="top" xoffset="19">axi_eth_tile.axis_out_tdest[0:3] axi_eth_tile.axis_out_tready axi_eth_tile.axis_out_tvalid axi_eth_tile.axis_in_tdest[0:4] axi_eth_tile.axis_in_tready axi_eth_tile.axis_in_tvalid</loc>
            
              <loc side="bottom" xoffset="0"> axi_eth_tile.eth_inpad[0:6]       axi_eth_tile.eth_outpad[0:6]</loc>
              <loc side="bottom" xoffset="1"> axi_eth_tile.eth_inpad[7:13]      axi_eth_tile.eth_outpad[7:13]</loc>
              <loc side="bottom" xoffset="2"> axi_eth_tile.eth_inpad[14:20]     axi_eth_tile.eth_outpad[14:20]</loc>
              <loc side="bottom" xoffset="3"> axi_eth_tile.eth_inpad[21:27]     axi_eth_tile.eth_outpad[21:27]</loc>
              <loc side="bottom" xoffset="4"> axi_eth_tile.eth_inpad[28:34]     axi_eth_tile.eth_outpad[28:34]</loc>
              <loc side="bottom" xoffset="5"> axi_eth_tile.eth_inpad[35:41]     axi_eth_tile.eth_outpad[35:41]</loc>
              <loc side="bottom" xoffset="6"> axi_eth_tile.eth_inpad[42:48]     axi_eth_tile.eth_outpad[42:48]</loc>
              <loc side="bottom" xoffset="7"> axi_eth_tile.eth_inpad[49:55]     axi_eth_tile.eth_outpad[49:55]</loc>
              <loc side="bottom" xoffset="8"> axi_eth_tile.eth_inpad[56:62]     axi_eth_tile.eth_outpad[56:62]</loc>
              <loc side="bottom" xoffset="9"> axi_eth_tile.eth_inpad[63:69]     axi_eth_tile.eth_outpad[63:69]</loc>
              <loc side="bottom" xoffset="10">axi_eth_tile.eth_inpad[70:76]     axi_eth_tile.eth_outpad[70:76]</loc>
              <loc side="bottom" xoffset="11">axi_eth_tile.eth_inpad[77:83]     axi_eth_tile.eth_outpad[77:83]</loc>
              <loc side="bottom" xoffset="12">axi_eth_tile.eth_inpad[84:90]     axi_eth_tile.eth_outpad[84:90]</loc>
              <loc side="bottom" xoffset="13">axi_eth_tile.eth_inpad[91:97]     axi_eth_tile.eth_outpad[91:97]</loc>
              <loc side="bottom" xoffset="14">axi_eth_tile.eth_inpad[98:104]    axi_eth_tile.eth_outpad[98:104]</loc>
              <loc side="bottom" xoffset="15">axi_eth_tile.eth_inpad[105:111]   axi_eth_tile.eth_outpad[105:111]</loc>
              <loc side="bottom" xoffset="16">axi_eth_tile.eth_inpad[112:118]   axi_eth_tile.eth_outpad[112:118]</loc>
              <loc side="bottom" xoffset="17">axi_eth_tile.eth_inpad[119:125]   axi_eth_tile.eth_outpad[119:125]</loc>
              <loc side="bottom" xoffset="18">axi_eth_tile.eth_inpad[126:127]   axi_eth_tile.eth_outpad[126:127]</loc>            
            </pinlocations>
        <switchblock_locations pattern="none"/>
      </sub_tile>
    </tile>
    <tile name="router_wrap_tile" height="3" width="3">
         <sub_tile name="router_wrap_tile">
            <equivalent_sites>
               <site pb_type="router_wrap_tile"/>
               </equivalent_sites>
            <input name="clk_noc" num_pins="1" is_non_clock_global="true"/>
            <clock name="clk_usr" num_pins="1"/>
            <input name="rst_n" num_pins="1" is_non_clock_global="true"/>
            
            <output name="credit_out" num_pins="4"/>
            <input name="data_in" num_pins="256"/>
            <input name="dest_in" num_pins="16"/>
            <input name="is_tail_in" num_pins="4"/>
            <input name="send_in" num_pins="4"/>

            <input name="credit_in" num_pins="4"/>
            <output name="data_out" num_pins="256"/>
            <output name="dest_out" num_pins="16"/>
            <output name="is_tail_out" num_pins="4"/>
            <output name="send_out" num_pins="4"/>

            <input name="router_address" num_pins="4"/>

            <input name="axis_in_tvalid" num_pins="1"/>
            <input name="axis_in_tdata" num_pins="128"/>
            <input name="axis_in_tlast" num_pins="1"/>
            <input name="axis_in_tid" num_pins="2"/>
            <input name="axis_in_tdest" num_pins="4"/>
            <input name="axis_out_tready" num_pins="1"/>

            <output name="axis_in_tready" num_pins="1"/>
            <output name="axis_out_tvalid" num_pins="1"/>
            <output name="axis_out_tdata" num_pins="128"/>
            <output name="axis_out_tlast" num_pins="1"/>
            <output name="axis_out_tid" num_pins="2"/>
            <output name="axis_out_tdest" num_pins="4"/>

            <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
            <!-- fc =0 for router to router ports -->
                <fc_override port_name="data_in" fc_type="frac" fc_val="0"/>
                <fc_override port_name="dest_in" fc_type="frac" fc_val="0"/>
                <fc_override port_name="is_tail_in" fc_type="frac" fc_val="0"/>
                <fc_override port_name="send_in" fc_type="frac" fc_val="0"/>
                <fc_override port_name="credit_out" fc_type="frac" fc_val="0"/>
                <fc_override port_name="data_out" fc_type="frac" fc_val="0"/>
                <fc_override port_name="dest_out" fc_type="frac" fc_val="0"/>
                <fc_override port_name="is_tail_out" fc_type="frac" fc_val="0"/>
                <fc_override port_name="send_out" fc_type="frac" fc_val="0"/>
                <fc_override port_name="credit_in" fc_type="frac" fc_val="0"/>
            </fc>
            <!-- <pinlocations pattern="custom">
              <loc side="left" yoffset="0">router_wrap_tile.axis_out_tdata[0:6] router_wrap_tile.axis_in_tdata[0:6] router_wrap_tile.axis_out_tdata[7:13] router_wrap_tile.axis_in_tdata[7:13]</loc>
              <loc side="left" yoffset="2">router_wrap_tile.axis_out_tdata[14:20] router_wrap_tile.axis_in_tdata[14:20]</loc>
              <loc side="left" yoffset="3">router_wrap_tile.axis_out_tdata[21:27] router_wrap_tile.axis_in_tdata[21:27]</loc>
              <loc side="left" yoffset="4">router_wrap_tile.axis_out_tdata[28:34] router_wrap_tile.axis_in_tdata[28:34]</loc>
              <loc side="left" yoffset="5">router_wrap_tile.axis_out_tdata[35:41] router_wrap_tile.axis_in_tdata[35:41]</loc>
              <loc side="left" yoffset="6">router_wrap_tile.axis_out_tdata[42:48] router_wrap_tile.axis_in_tdata[42:48]</loc>
              <loc side="left" yoffset="7">router_wrap_tile.axis_out_tdata[49:55] router_wrap_tile.axis_in_tdata[49:55]</loc>
              <loc side="left" yoffset="8"> router_wrap_tile.data_in[192:255] router_wrap_tile.dest_in[12:15] router_wrap_tile.data_out[192:255] router_wrap_tile.dest_out[12:15] router_wrap_tile.is_tail_in[3:3] router_wrap_tile.send_in[3:3] router_wrap_tile.credit_out[3:3] router_wrap_tile.is_tail_out[3:3] router_wrap_tile.send_out[3:3] router_wrap_tile.credit_in[3:3] router_wrap_tile.axis_out_tdata[56:62] router_wrap_tile.axis_in_tdata[56:62]</loc>

              <loc side="right" yoffset="0">router_wrap_tile.axis_out_tdata[63:69] router_wrap_tile.axis_in_tdata[63:69]</loc>
              <loc side="right" yoffset="1">router_wrap_tile.axis_out_tdata[70:76] router_wrap_tile.axis_in_tdata[70:76]</loc>
              <loc side="right" yoffset="2">router_wrap_tile.axis_out_tdata[77:83] router_wrap_tile.axis_in_tdata[77:83]</loc>
              <loc side="right" yoffset="3">router_wrap_tile.axis_out_tdata[84:90] router_wrap_tile.axis_in_tdata[84:90]</loc>
              <loc side="right" yoffset="4">router_wrap_tile.axis_out_tdata[91:97] router_wrap_tile.axis_in_tdata[91:97]</loc>
              <loc side="right" yoffset="5">router_wrap_tile.axis_out_tdata[98:104] router_wrap_tile.axis_in_tdata[98:104]</loc>
              <loc side="right" yoffset="6">router_wrap_tile.axis_out_tdata[105:111] router_wrap_tile.axis_in_tdata[105:111]</loc>
              <loc side="right" yoffset="7">router_wrap_tile.axis_out_tdata[112:118] router_wrap_tile.axis_in_tdata[112:118]</loc>
              <loc side="right" yoffset="8">router_wrap_tile.data_in[128:191] router_wrap_tile.dest_in[4:7] router_wrap_tile.data_out[128:191] router_wrap_tile.dest_out[4:7] router_wrap_tile.is_tail_in[2:2] router_wrap_tile.send_in[2:2] router_wrap_tile.credit_out[2:2] router_wrap_tile.is_tail_out[2:2] router_wrap_tile.send_out[2:2] router_wrap_tile.credit_in[2:2] router_wrap_tile.axis_out_tdata[119:125] router_wrap_tile.axis_in_tdata[119:125]</loc>

              <loc side="bottom" yoffset="0">router_wrap_tile.router_address router_wrap_tile.data_in[64:127] router_wrap_tile.dest_in[8:11] router_wrap_tile.data_out[64:127] router_wrap_tile.dest_out[8:11] router_wrap_tile.is_tail_in[1:1] router_wrap_tile.send_in[1:1] router_wrap_tile.credit_out[1:1] router_wrap_tile.is_tail_out[1:1] router_wrap_tile.send_out[1:1] router_wrap_tile.credit_in[1:1] router_wrap_tile.axis_out_tdata[126:127] router_wrap_tile.axis_in_tdata[126:127] router_wrap_tile.axis_out_tlast router_wrap_tile.axis_out_tid[0:1] router_wrap_tile.axis_in_tlast router_wrap_tile.axis_in_tid[0:1]</loc>
              <loc side="top"    yoffset="8">router_wrap_tile.clk_noc router_wrap_tile.clk_usr router_wrap_tile.rst_n router_wrap_tile.data_in[0:63]  router_wrap_tile.dest_in[0:3]  router_wrap_tile.data_out[0:63]  router_wrap_tile.dest_out[0:3]  router_wrap_tile.is_tail_in[0:0]  router_wrap_tile.send_in[0:0]  router_wrap_tile.credit_out[0:0]  router_wrap_tile.is_tail_out[0:0]  router_wrap_tile.send_out[0:0]  router_wrap_tile.credit_in[0:0] router_wrap_tile.axis_out_tdest[0:3] router_wrap_tile.axis_out_tready router_wrap_tile.axis_out_tvalid router_wrap_tile.axis_in_tdest[0:4] router_wrap_tile.axis_in_tready router_wrap_tile.axis_in_tvalid</loc>
            </pinlocations> -->
            <switchblock_locations pattern="all"/>
            </sub_tile>
         </tile>
      </tiles>
  <!-- ODIN II specific config ends -->
  <!-- Physical descriptions begin -->
  <layout>
  <!-- <layout tileable="true" through_channel="true" opin2all_sides="true" concat_wire="true" concat_pass_wire="true"> -->
  <fixed_layout name="large" width="88" height="80">
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="110"/>

      <!-- <row type="axi_hbm_tile" startx="1" starty="0" priority="105"/> 
      <single type="axi_hbm_tile" x="1" y="0" priority="105"/>
      <single type="axi_eth_tile" x="278" y="0" priority="105"/>-->

      <fill type="clb" priority="10"/>

      <!--Column of 'memory' with 'EMPTY' blocks wherever a 'memory' does not fit. Vertical offset by 1 for perimeter.-->
      <col type="memory" startx="2" starty="1" repeatx="7" priority="30"/>
      <col type="EMPTY"  startx="2"  starty="1" repeatx="7" priority="29"/>

      <!--Column of 'mult_36' with 'EMPTY' blocks wherever a 'mult_36' does not fit. Vertical offset by 1 for perimeter.-->
      <col type="dsp_top" startx="6" starty="1" repeatx="8" priority="20"/>
      <col type="EMPTY"   startx="6" starty="1" repeatx="8" priority="19"/>
      
      <!-- 16 routers as a 4x4 mesh -->
      <!-- first rtr at 48,48 -->
<!-- Top Row -->
  <single type="router_wrap_tile" x="W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="9*W/11" y="H/10" priority="50"/>
  <single type="router_wrap_tile" x="10*W/11" y="H/10" priority="50"/>

  <!-- Row 2 -->
  <single type="router_wrap_tile" x="W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="2*H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="2*H/10" priority="50"/>

  <!-- Row 3 -->
  <single type="router_wrap_tile" x="W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="3*H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="3*H/10" priority="50"/>

  <!-- Row 4 -->
  <single type="router_wrap_tile" x="W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="7*H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="7*H/10" priority="50"/>

  <!-- Row 5 -->
  <single type="router_wrap_tile" x="W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="8*H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="8*H/10" priority="50"/>

  <!-- Bottom Row -->
  <single type="router_wrap_tile" x="W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="2*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="3*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="4*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="5*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="6*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="7*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="8*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="9*W/11" y="9*H/10" priority="50"/>
  <single type="router_wrap_tile" x="10*W/11" y="9*H/10" priority="50"/>
      </fixed_layout>
   </layout>
  <device>
    <!-- VB & JL: Using Ian Kuon's transistor sizing and drive strength data for routing, at 40 nm. Ian used BPTM 
			     models. We are modifying the delay values however, to include metal C and R, which allows more architecture
			     experimentation. We are also modifying the relative resistance of PMOS to be 1.8x that of NMOS
			     (vs. Ian's 3x) as 1.8x lines up with Jeff G's data from a 45 nm process (and is more typical of 
			     45 nm in general). I'm upping the Rmin_nmos from Ian's just over 6k to nearly 9k, and dropping 
			     RminW_pmos from 18k to 16k to hit this 1.8x ratio, while keeping the delays of buffers approximately
			     lined up with Stratix IV. 
			     We are using Jeff G.'s capacitance data for 45 nm (in tech/ptm_45nm).
			     Jeff's tables list C in for transistors with widths in multiples of the minimum feature size (45 nm).
			     The minimum contactable transistor is 2.5 * 45 nm, so I need to multiply drive strength sizes in this file
	                     by 2.5x when looking up in Jeff's tables.
			     The delay values are lined up with Stratix IV, which has an architecture similar to this
			     proposed FPGA, and which is also 40 nm 
			     C_ipin_cblock: input capacitance of a track buffer, which VPR assumes is a single-stage
			     4x minimum drive strength buffer. -->
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>
    <!-- The grid_logic_tile_area below will be used for all blocks that do not explicitly set their own (non-routing)
     	  area; set to 0 since we explicitly set the area of all blocks currently in this architecture file.
	    -->
    <area grid_logic_tile_area="0"/>
    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="wilton" fs="3"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>
  <switchlist>
    <!-- VB: the mux_trans_size and buf_size data below is in minimum width transistor *areas*, assuming the purple
           book area formula. This means the mux transistors are about 5x minimum drive strength.
           We assume the first stage of the buffer is 3x min drive strength to be reasonable given the large 
           mux transistors, and this gives a reasonable stage ratio of a bit over 5x to the second stage. We assume
           the n and p transistors in the first stage are equal-sized to lower the buffer trip point, since it's fed
           by a pass transistor mux. We can then reverse engineer the buffer second stage to hit the specified 
           buf_size (really buffer area) - 16.2x minimum drive nmos and 1.8*16.2 = 29.2x minimum drive.
           I then took the data from Jeff G.'s PTM modeling of 45 nm to get the Cin (gate of first stage) and Cout 
           (diff of second stage) listed below.  Jeff's models are in tech/ptm_45nm, and are in min feature multiples.
           The minimum contactable transistor is 2.5 * 45 nm, so I need to multiply the drive strength sizes above by 
           2.5x when looking up in Jeff's tables.
           Finally, we choose a switch delay (58 ps) that leads to length 4 wires having a delay equal to that of SIV of 126 ps.
           This also leads to the switch being 46% of the total wire delay, which is reasonable. -->
    <switch type="mux" name="0" R="551" Cin=".77e-15" Cout="4e-15" Tdel="58e-12" mux_trans_size="2.630740" buf_size="27.645901"/>
    <!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer-->
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="7.247000e-11" mux_trans_size="1.222260" buf_size="auto"/>
  </switchlist>
  <segmentlist>
    <!--- VB & JL: using ITRS metal stack data, 96 nm half pitch wires, which are intermediate metal width/space.  
             With the 96 nm half pitch, such wires would take 60 um of height, vs. a 90 nm high (approximated as square) Stratix IV tile so this seems
             reasonable. Using a tile length of 90 nm, corresponding to the length of a Stratix IV tile if it were square. -->
    <!-- GIVE a specific name for the segment! OpenFPGA appreciate that! -->
    <segment name="L4" freq="1.000000" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>
  </segmentlist>
  <directlist>
    <direct name="adder_carry" from_pin="clb.cout" to_pin="clb.cin" x_offset="0" y_offset="-1" z_offset="0"/>
    <!-- hbm to rtr -->
    <!-- hbm data_out[0:63] is at 1,1; data in at 2,1  and rtr data_in[64:127]& data_out is at 60,60 -->
    <!-- <direct name="hbm_to_rtr_data"    from_pin="axi_hbm_tile.data_out[0:63]"   to_pin="router_wrap_tile.data_in[64:127]" x_offset="59" y_offset="59" z_offset="0"/> -->
    <!-- <direct name="hbm_to_rtr_dest"    from_pin="axi_hbm_tile.dest_out[0:3]"    to_pin="router_wrap_tile.dest_in[8:11]"   x_offset="59" y_offset="59" z_offset="0"/> -->
    <!-- <direct name="hbm_to_rtr_is_tail" from_pin="axi_hbm_tile.is_tail_out[0:0]" to_pin="router_wrap_tile.is_tail_in[1:1]" x_offset="59" y_offset="59" z_offset="0"/> -->
    <!-- <direct name="hbm_to_rtr_send"    from_pin="axi_hbm_tile.send_out[0:0]"    to_pin="router_wrap_tile.send_in[1:1]"    x_offset="59" y_offset="59" z_offset="0"/> -->
    <!-- <direct name="hbm_to_rtr_credit"  from_pin="axi_hbm_tile.credit_out[0:0]"  to_pin="router_wrap_tile.credit_in[1:1]"  x_offset="59" y_offset="59" z_offset="0"/> -->
    <!-- rtr to hbm -->
    <!-- <direct name="rtr_to_hbm_data"    from_pin="router_wrap_tile.data_out[64:127]"  to_pin="axi_hbm_tile.data_in[0:63]"   x_offset="-59" y_offset="-59" z_offset="0"/> -->
    <!-- <direct name="rtr_to_hbm_dest"    from_pin="router_wrap_tile.dest_out[8:11]"    to_pin="axi_hbm_tile.dest_in[0:3]"    x_offset="-59" y_offset="-59" z_offset="0"/> -->
    <!-- <direct name="rtr_to_hbm_is_tail" from_pin="router_wrap_tile.is_tail_out[1:1]"  to_pin="axi_hbm_tile.is_tail_in[0:0]" x_offset="-59" y_offset="-59" z_offset="0"/> -->
    <!-- <direct name="rtr_to_hbm_send"    from_pin="router_wrap_tile.send_out[1:1]"     to_pin="axi_hbm_tile.send_in[0:0]"    x_offset="-59" y_offset="-59" z_offset="0"/> -->
    <!-- <direct name="rtr_to_hbm_credit"  from_pin="router_wrap_tile.credit_out[1:1]"   to_pin="axi_hbm_tile.credit_in[0:0]"  x_offset="-59" y_offset="-59" z_offset="0"/> -->
  </directlist>
  <complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
    <!-- Not sure of the area of an I/O (varies widely), and it's not relevant to the design of the FPGA core, so we're setting it to 0. -->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <!-- Do NOT add clock pins to I/O here!!! VPR does not build clock network in the way that OpenFPGA can support
           If you need to register the I/O, define clocks in the circuit models
           These clocks can be handled in back-end
       -->
      <!-- A mode denotes the physical implementation of an I/O 
           This mode will be not packable but is mainly used for fabric verilog generation   
        -->
      <mode name="physical" disable_packing="true">
        <pb_type name="iopad" blif_model=".subckt io" num_pb="1">
          <input name="outpad" num_pins="1"/>
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="iopad.outpad">
            <delay_constant max="1.394e-11" in_port="io.outpad" out_port="iopad.outpad"/>
          </direct>
          <direct name="inpad" input="iopad.inpad" output="io.inpad">
            <delay_constant max="4.243e-11" in_port="iopad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- IOs can operate as either inputs or outputs.
	     Delays below come from Ian Kuon. They are small, so they should be interpreted as
	     the delays to and from registers in the I/O (and generally I/Os are registered 
	     today and that is when you timing analyze them.
	     -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <delay_constant max="4.243e-11" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="1.394e-11" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
      <!-- Place I/Os on the sides of the FPGA -->
      <power method="ignore"/>
    </pb_type>
    <!-- Define I/O pads ends -->
    <!-- Define general purpose logic block (CLB) begin -->
    <!--- Area calculation: Total Stratix IV tile area is about 8100 um^2, and a minimum width transistor 
	   area is 60 L^2 yields a tile area of 84375 MWTAs.
	   Routing at W=300 is 30481 MWTAs, leaving us with a total of 53000 MWTAs for logic block area 
	   This means that only 37% of our area is in the general routing, and 63% is inside the logic
	   block. Note that the crossbar / local interconnect is considered part of the logic block
	   area in this analysis. That is a lower proportion of of routing area than most academics
	   assume, but note that the total routing area really includes the crossbar, which would push
	   routing area up significantly, we estimate into the ~70% range. 
	   -->
    <pb_type name="clb">
      <input name="I" num_pins="40" equivalent="full"/>
      <input name="cin" num_pins="1"/>
      <input name="set" num_pins="1" is_non_clock_global="true"/>
      <input name="reset" num_pins="1" is_non_clock_global="true"/>
      <output name="O" num_pins="20" equivalent="none"/>
      <output name="cout" num_pins="1"/>
      <clock name="clk" num_pins="1"/>
      <!-- Describe fracturable logic element.  
             Each fracturable logic element has a 6-LUT that can alternatively operate as two 5-LUTs with shared inputs. 
             The outputs of the fracturable logic element can be optionally registered
        -->
      <pb_type name="fle" num_pb="10">
        <input name="in" num_pins="6"/>
        <input name="cin" num_pins="1"/>
        <input name="set" num_pins="1"/>
        <input name="reset" num_pins="1"/>
        <output name="out" num_pins="2"/>
        <output name="cout" num_pins="1"/>
        <clock name="clk" num_pins="1"/>
        <!-- Physical mode definition begin (physical implementation of the fle) -->
        <mode name="physical" disable_packing="true">
          <pb_type name="fabric" num_pb="1">
            <input name="in" num_pins="6"/>
            <input name="cin" num_pins="1"/>
            <input name="set" num_pins="1"/>
            <input name="reset" num_pins="1"/>
            <output name="out" num_pins="2"/>
            <output name="cout" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <pb_type name="frac_logic" num_pb="1">
              <input name="in" num_pins="6"/>
              <output name="lut4_out" num_pins="4"/>
              <output name="out" num_pins="2"/>
              <!-- Define LUT -->
              <pb_type name="frac_lut6" blif_model=".subckt frac_lut6" num_pb="1">
                <input name="in" num_pins="6"/>
                <output name="lut4_out" num_pins="4"/>
                <output name="lut5_out" num_pins="2"/>
                <output name="lut6_out" num_pins="1"/>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="frac_logic.in" output="frac_lut6.in"/>
                <direct name="direct2" input="frac_lut6.lut4_out" output="frac_logic.lut4_out"/>
                <direct name="direct3" input="frac_lut6.lut5_out[1]" output="frac_logic.out[1]"/>
                <!-- Xifan Tang: I use out[0] because the output of lut6 in lut6 mode is wired to the out[0] -->
                <mux name="mux1" input="frac_lut6.lut6_out frac_lut6.lut5_out[0]" output="frac_logic.out[0]"/>
              </interconnect>
            </pb_type>
            <!-- Define flip-flop -->
            <pb_type name="ff" blif_model=".subckt dffsr" num_pb="2">
              <input name="D" num_pins="1" port_class="D"/>
              <input name="R" num_pins="1"/>
              <input name="S" num_pins="1"/>
              <output name="Q" num_pins="1" port_class="Q"/>
              <clock name="C" num_pins="1" port_class="clock"/>
              <T_setup value="66e-12" port="ff.D" clock="C"/>
              <T_setup value="66e-12" port="ff.R" clock="C"/>
              <T_setup value="66e-12" port="ff.S" clock="C"/>
              <T_clock_to_Q max="124e-12" port="ff.Q" clock="C"/>
            </pb_type>
            <!-- Define adders -->
            <pb_type name="adder" blif_model=".subckt adder" num_pb="2">
              <input name="a" num_pins="1"/>
              <input name="b" num_pins="1"/>
              <input name="cin" num_pins="1"/>
              <output name="cout" num_pins="1"/>
              <output name="sumout" num_pins="1"/>
              <delay_constant max="0.3e-9" in_port="adder.a" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.b" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.cin" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.a" out_port="adder.cout"/>
              <delay_constant max="0.3e-9" in_port="adder.b" out_port="adder.cout"/>
              <delay_constant max="0.01e-9" in_port="adder.cin" out_port="adder.cout"/>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="fabric.in" output="frac_logic.in"/>
              <direct name="direct2" input="frac_logic.out[1:0]" output="ff[1:0].D"/>
              <direct name="direct3" input="fabric.cin" output="adder[0:0].cin"/>
              <direct name="direct4" input="adder[0:0].cout" output="adder[1:1].cin"/>
              <direct name="direct5" input="adder[1:1].cout" output="fabric.cout"/>
              <direct name="direct6" input="frac_logic.lut4_out[0:0]" output="adder[0:0].a"/>
              <direct name="direct7" input="frac_logic.lut4_out[1:1]" output="adder[0:0].b"/>
              <direct name="direct8" input="frac_logic.lut4_out[2:2]" output="adder[1:1].a"/>
              <direct name="direct9" input="frac_logic.lut4_out[3:3]" output="adder[1:1].b"/>
              <complete name="direct10" input="fabric.clk" output="ff[1:0].C"/>
              <complete name="direct11" input="fabric.reset" output="ff[1:0].R"/>
              <complete name="direct12" input="fabric.set" output="ff[1:0].S"/>
              <mux name="mux1" input="adder[0].sumout ff[0].Q frac_logic.out[0]" output="fabric.out[0]">
                <!-- LUT to output is faster than FF to output on a Stratix IV -->
                <delay_constant max="25e-12" in_port="frac_logic.out[0]" out_port="fabric.out[0]"/>
                <delay_constant max="45e-12" in_port="ff[0].Q" out_port="fabric.out[0]"/>
              </mux>
              <mux name="mux2" input="adder[1].sumout ff[1].Q frac_logic.out[1]" output="fabric.out[1]">
                <!-- LUT to output is faster than FF to output on a Stratix IV -->
                <delay_constant max="25e-12" in_port="frac_logic.out[1]" out_port="fabric.out[1]"/>
                <delay_constant max="45e-12" in_port="ff[1].Q" out_port="fabric.out[1]"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in" output="fabric.in"/>
            <direct name="direct2" input="fle.cin" output="fabric.cin"/>
            <direct name="direct3" input="fabric.out" output="fle.out"/>
            <direct name="direct4" input="fabric.cout" output="fle.cout"/>
            <direct name="direct5" input="fle.clk" output="fabric.clk"/>
            <direct name="direct6" input="fle.reset" output="fabric.reset"/>
            <direct name="direct7" input="fle.set" output="fabric.set"/>
          </interconnect>
        </mode>
        <!-- Physical mode definition end (physical implementation of the fle) -->
        <!-- BEGIN fle mode of dual lut5 -->
        <mode name="n2_lut5">
          <pb_type name="ble5" num_pb="2">
            <input name="in" num_pins="5"/>
            <input name="set" num_pins="1"/>
            <input name="reset" num_pins="1"/>
            <output name="out" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <!-- Regular LUT mode -->
            <pb_type name="lut5" blif_model=".names" num_pb="1" class="lut">
              <input name="in" num_pins="5" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <!-- LUT timing using delay matrix -->
              <!-- These are the physical delay inputs on a Stratix IV LUT but because VPR cannot do LUT rebalancing,
                  we instead take the average of these numbers to get more stable results
                82e-12
                173e-12
                261e-12
                263e-12
                398e-12
                -->
              <delay_matrix type="max" in_port="lut5.in" out_port="lut5.out">
                235e-12
                235e-12
                235e-12
                235e-12
                235e-12
              </delay_matrix>
            </pb_type>
            <!-- Define multi-mode flip-flop -->
            <pb_type name="ff" num_pb="1">
              <input name="D" num_pins="1"/>
              <input name="R" num_pins="1"/>
              <input name="S" num_pins="1"/>
              <output name="Q" num_pins="1"/>
              <clock name="C" num_pins="1"/>
              <mode name="latch">
                <pb_type name="latch" blif_model=".latch" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="latch.D" clock="clk"/>
                  <T_clock_to_Q max="124e-12" port="latch.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="latch.D"/>
                  <direct name="direct2" input="ff.C" output="latch.clk"/>
                  <direct name="direct3" input="latch.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dff">
                <pb_type name="dff" blif_model=".subckt dff" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dff.D" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dff.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dff.D"/>
                  <direct name="direct2" input="ff.C" output="dff.C"/>
                  <direct name="direct3" input="dff.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffr">
                <pb_type name="dffr" blif_model=".subckt dffr" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffr.D" clock="C"/>
                  <T_setup value="66e-12" port="dffr.R" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffr.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffr.D"/>
                  <direct name="direct2" input="ff.C" output="dffr.C"/>
                  <direct name="direct3" input="ff.R" output="dffr.R"/>
                  <direct name="direct4" input="dffr.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffrn">
                <pb_type name="dffrn" blif_model=".subckt dffrn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="RN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffrn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffrn.RN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffrn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffrn.D"/>
                  <direct name="direct2" input="ff.C" output="dffrn.C"/>
                  <direct name="direct3" input="ff.R" output="dffrn.RN"/>
                  <direct name="direct4" input="dffrn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffs">
                <pb_type name="dffs" blif_model=".subckt dffs" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="S" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffs.D" clock="C"/>
                  <T_setup value="66e-12" port="dffs.S" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffs.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffs.D"/>
                  <direct name="direct2" input="ff.C" output="dffs.C"/>
                  <direct name="direct3" input="ff.S" output="dffs.S"/>
                  <direct name="direct4" input="dffs.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffsn">
                <pb_type name="dffsn" blif_model=".subckt dffsn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="SN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffsn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffsn.SN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffsn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffsn.D"/>
                  <direct name="direct2" input="ff.C" output="dffsn.C"/>
                  <direct name="direct3" input="ff.S" output="dffsn.SN"/>
                  <direct name="direct4" input="dffsn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="ble5.in" output="lut5.in"/>
              <direct name="direct2" input="lut5.out" output="ff.D">
                <pack_pattern name="ble5" in_port="lut5.out" out_port="ff.D"/>
              </direct>
              <direct name="direct3" input="ble5.clk" output="ff.C"/>
              <direct name="direct4" input="ble5.reset" output="ff.R"/>
              <direct name="direct5" input="ble5.set" output="ff.S"/>
              <mux name="mux1" input="ff.Q lut5.out" output="ble5.out">
                <delay_constant max="25e-12" in_port="lut5.out" out_port="ble5.out"/>
                <delay_constant max="45e-12" in_port="ff.Q" out_port="ble5.out"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in[4:0]" output="ble5[0:0].in"/>
            <direct name="direct2" input="fle.in[4:0]" output="ble5[1:1].in"/>
            <complete name="direct3" input="fle.clk" output="ble5.clk"/>
            <direct name="direct4" input="ble5.out" output="fle.out"/>
            <complete name="direct5" input="fle.reset" output="ble5.reset"/>
            <complete name="direct6" input="fle.set" output="ble5.set"/>
          </interconnect>
        </mode>
        <!-- END fle mode of dual lut5 -->
        <!-- BEGIN arithmetic mode of dual lut4 + adders -->
        <mode name="arithmetic">
          <pb_type name="arithmetic" num_pb="2">
            <input name="in" num_pins="4"/>
            <input name="cin" num_pins="1"/>
            <input name="set" num_pins="1"/>
            <input name="reset" num_pins="1"/>
            <output name="out" num_pins="1"/>
            <output name="cout" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <!-- Special dual-LUT mode that drives adder only -->
            <pb_type name="lut4" blif_model=".names" num_pb="2" class="lut">
              <input name="in" num_pins="4" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <!-- LUT timing using delay matrix -->
              <!-- These are the physical delay inputs on a Stratix IV LUT but because VPR cannot do LUT rebalancing,
                       we instead take the average of these numbers to get more stable results
                  82e-12
                  173e-12
                  261e-12
                  263e-12
                  -->
              <delay_matrix type="max" in_port="lut4.in" out_port="lut4.out">
                  195e-12
                  195e-12
                  195e-12
                  195e-12
                </delay_matrix>
            </pb_type>
            <pb_type name="adder" blif_model=".subckt adder" num_pb="1">
              <input name="a" num_pins="1"/>
              <input name="b" num_pins="1"/>
              <input name="cin" num_pins="1"/>
              <output name="cout" num_pins="1"/>
              <output name="sumout" num_pins="1"/>
              <delay_constant max="0.3e-9" in_port="adder.a" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.b" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.cin" out_port="adder.sumout"/>
              <delay_constant max="0.3e-9" in_port="adder.a" out_port="adder.cout"/>
              <delay_constant max="0.3e-9" in_port="adder.b" out_port="adder.cout"/>
              <delay_constant max="0.01e-9" in_port="adder.cin" out_port="adder.cout"/>
            </pb_type>
            <!-- Define multi-mode flip-flop -->
            <pb_type name="ff" num_pb="1">
              <input name="D" num_pins="1"/>
              <input name="R" num_pins="1"/>
              <input name="S" num_pins="1"/>
              <output name="Q" num_pins="1"/>
              <clock name="C" num_pins="1"/>
              <mode name="latch">
                <pb_type name="latch" blif_model=".latch" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="latch.D" clock="clk"/>
                  <T_clock_to_Q max="124e-12" port="latch.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="latch.D"/>
                  <direct name="direct2" input="ff.C" output="latch.clk"/>
                  <direct name="direct3" input="latch.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dff">
                <pb_type name="dff" blif_model=".subckt dff" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dff.D" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dff.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dff.D"/>
                  <direct name="direct2" input="ff.C" output="dff.C"/>
                  <direct name="direct3" input="dff.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffr">
                <pb_type name="dffr" blif_model=".subckt dffr" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffr.D" clock="C"/>
                  <T_setup value="66e-12" port="dffr.R" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffr.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffr.D"/>
                  <direct name="direct2" input="ff.C" output="dffr.C"/>
                  <direct name="direct3" input="ff.R" output="dffr.R"/>
                  <direct name="direct4" input="dffr.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffrn">
                <pb_type name="dffrn" blif_model=".subckt dffrn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="RN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffrn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffrn.RN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffrn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffrn.D"/>
                  <direct name="direct2" input="ff.C" output="dffrn.C"/>
                  <direct name="direct3" input="ff.R" output="dffrn.RN"/>
                  <direct name="direct4" input="dffrn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffs">
                <pb_type name="dffs" blif_model=".subckt dffs" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="S" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffs.D" clock="C"/>
                  <T_setup value="66e-12" port="dffs.S" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffs.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffs.D"/>
                  <direct name="direct2" input="ff.C" output="dffs.C"/>
                  <direct name="direct3" input="ff.S" output="dffs.S"/>
                  <direct name="direct4" input="dffs.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffsn">
                <pb_type name="dffsn" blif_model=".subckt dffsn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="SN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffsn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffsn.SN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffsn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffsn.D"/>
                  <direct name="direct2" input="ff.C" output="dffsn.C"/>
                  <direct name="direct3" input="ff.S" output="dffsn.SN"/>
                  <direct name="direct4" input="dffsn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <direct name="clock" input="arithmetic.clk" output="ff.C"/>
              <direct name="set" input="arithmetic.set" output="ff.S"/>
              <direct name="reset" input="arithmetic.reset" output="ff.R"/>
              <direct name="lut_in1" input="arithmetic.in[3:0]" output="lut4[0:0].in[3:0]"/>
              <direct name="lut_in2" input="arithmetic.in[3:0]" output="lut4[1:1].in[3:0]"/>
              <direct name="lut_to_add1" input="lut4[0:0].out" output="adder.a">
                </direct>
              <direct name="lut_to_add2" input="lut4[1:1].out" output="adder.b">
                </direct>
              <direct name="add_to_ff" input="adder.sumout" output="ff.D">
                <pack_pattern name="chain" in_port="adder.sumout" out_port="ff.D"/>
              </direct>
              <direct name="carry_in" input="arithmetic.cin" output="adder.cin">
                <pack_pattern name="chain" in_port="arithmetic.cin" out_port="adder.cin"/>
              </direct>
              <direct name="carry_out" input="adder.cout" output="arithmetic.cout">
                <pack_pattern name="chain" in_port="adder.cout" out_port="arithmetic.cout"/>
              </direct>
              <mux name="sumout" input="ff.Q adder.sumout" output="arithmetic.out">
                <delay_constant max="25e-12" in_port="adder.sumout" out_port="arithmetic.out"/>
                <delay_constant max="45e-12" in_port="ff.Q" out_port="arithmetic.out"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in[3:0]" output="arithmetic[0:0].in"/>
            <direct name="direct2" input="fle.in[3:0]" output="arithmetic[1:1].in"/>
            <direct name="carry_in" input="fle.cin" output="arithmetic[0:0].cin">
              <pack_pattern name="chain" in_port="fle.cin" out_port="arithmetic[0:0].cin"/>
            </direct>
            <direct name="carry_inter" input="arithmetic[0:0].cout" output="arithmetic[1:1].cin">
              <pack_pattern name="chain" in_port="arithmetic[0:0].cout" out_port="arithmetic[1:1].cin"/>
            </direct>
            <direct name="carry_out" input="arithmetic[1:1].cout" output="fle.cout">
              <pack_pattern name="chain" in_port="arithmetic.cout" out_port="fle.cout"/>
            </direct>
            <complete name="direct3" input="fle.clk" output="arithmetic.clk"/>
            <complete name="direct4" input="fle.reset" output="arithmetic.reset"/>
            <complete name="direct5" input="fle.set" output="arithmetic.set"/>
            <direct name="direct6" input="arithmetic.out" output="fle.out"/>
          </interconnect>
        </mode>
        <!-- n2_lut5 -->
        <mode name="n1_lut6">
          <pb_type name="ble6" num_pb="1">
            <input name="in" num_pins="6"/>
            <input name="set" num_pins="1"/>
            <input name="reset" num_pins="1"/>
            <output name="out" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
              <input name="in" num_pins="6" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <!-- LUT timing using delay matrix -->
              <!-- These are the physical delay inputs on a Stratix IV LUT but because VPR cannot do LUT rebalancing,
                       we instead take the average of these numbers to get more stable results
                  82e-12
                  173e-12
                  261e-12
                  263e-12
                  398e-12
                  397e-12
                  -->
              <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                  261e-12
                  261e-12
                  261e-12
                  261e-12
                  261e-12
                  261e-12
                </delay_matrix>
            </pb_type>
            <!-- Define multi-mode flip-flop -->
            <pb_type name="ff" num_pb="1">
              <input name="D" num_pins="1"/>
              <input name="R" num_pins="1"/>
              <input name="S" num_pins="1"/>
              <output name="Q" num_pins="1"/>
              <clock name="C" num_pins="1"/>
              <mode name="latch">
                <pb_type name="latch" blif_model=".latch" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="latch.D" clock="clk"/>
                  <T_clock_to_Q max="124e-12" port="latch.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="latch.D"/>
                  <direct name="direct2" input="ff.C" output="latch.clk"/>
                  <direct name="direct3" input="latch.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dff">
                <pb_type name="dff" blif_model=".subckt dff" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dff.D" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dff.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dff.D"/>
                  <direct name="direct2" input="ff.C" output="dff.C"/>
                  <direct name="direct3" input="dff.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffr">
                <pb_type name="dffr" blif_model=".subckt dffr" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffr.D" clock="C"/>
                  <T_setup value="66e-12" port="dffr.R" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffr.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffr.D"/>
                  <direct name="direct2" input="ff.C" output="dffr.C"/>
                  <direct name="direct3" input="ff.R" output="dffr.R"/>
                  <direct name="direct4" input="dffr.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffrn">
                <pb_type name="dffrn" blif_model=".subckt dffrn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="RN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffrn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffrn.RN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffrn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffrn.D"/>
                  <direct name="direct2" input="ff.C" output="dffrn.C"/>
                  <direct name="direct3" input="ff.R" output="dffrn.RN"/>
                  <direct name="direct4" input="dffrn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffs">
                <pb_type name="dffs" blif_model=".subckt dffs" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="S" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffs.D" clock="C"/>
                  <T_setup value="66e-12" port="dffs.S" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffs.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffs.D"/>
                  <direct name="direct2" input="ff.C" output="dffs.C"/>
                  <direct name="direct3" input="ff.S" output="dffs.S"/>
                  <direct name="direct4" input="dffs.Q" output="ff.Q"/>
                </interconnect>
              </mode>
              <mode name="dffsn">
                <pb_type name="dffsn" blif_model=".subckt dffsn" num_pb="1">
                  <input name="D" num_pins="1" port_class="D"/>
                  <input name="SN" num_pins="1"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="C" num_pins="1" port_class="clock"/>
                  <T_setup value="66e-12" port="dffsn.D" clock="C"/>
                  <T_setup value="66e-12" port="dffsn.SN" clock="C"/>
                  <T_clock_to_Q max="124e-12" port="dffsn.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="ff.D" output="dffsn.D"/>
                  <direct name="direct2" input="ff.C" output="dffsn.C"/>
                  <direct name="direct3" input="ff.S" output="dffsn.SN"/>
                  <direct name="direct4" input="dffsn.Q" output="ff.Q"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="ble6.in" output="lut6[0:0].in"/>
              <direct name="direct2" input="lut6.out" output="ff.D">
                <pack_pattern name="ble6" in_port="lut6.out" out_port="ff.D"/>
              </direct>
              <direct name="direct3" input="ble6.clk" output="ff.C"/>
              <direct name="direct4" input="ble6.reset" output="ff.R"/>
              <direct name="direct5" input="ble6.set" output="ff.S"/>
              <mux name="mux1" input="ff.Q lut6.out" output="ble6.out">
                <delay_constant max="25e-12" in_port="lut6.out" out_port="ble6.out"/>
                <delay_constant max="45e-12" in_port="ff.Q" out_port="ble6.out"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in[5:0]" output="ble6.in"/>
            <direct name="direct2" input="ble6.out" output="fle.out[0:0]"/>
            <direct name="direct3" input="fle.clk" output="ble6.clk"/>
            <direct name="direct4" input="fle.reset" output="ble6.reset"/>
            <direct name="direct5" input="fle.set" output="ble6.set"/>
          </interconnect>
        </mode>
        <!-- n1_lut6 -->
      </pb_type>
      <interconnect>
        <!-- We use a 50% depop crossbar built using small full xbars to get sets of logically equivalent pins at inputs of CLB 
           The delays below come from Stratix IV. the delay through a connection block
           input mux + the crossbar in Stratix IV is 167 ps. We already have a 72 ps 
           delay on the connection block input mux (modeled by Ian Kuon), so the remaining
           delay within the crossbar is 95 ps. 
           The delays of cluster feedbacks in Stratix IV is 100 ps, when driven by a LUT.
           Since all our outputs LUT outputs go to a BLE output, and have a delay of 
           25 ps to do so, we subtract 25 ps from the 100 ps delay of a feedback
           to get the part that should be marked on the crossbar.	 -->
        <complete name="crossbar" input="clb.I fle[9:0].out" output="fle[9:0].in">
          <delay_constant max="95e-12" in_port="clb.I" out_port="fle[9:0].in"/>
          <delay_constant max="75e-12" in_port="fle[9:0].out" out_port="fle[9:0].in"/>
        </complete>
        <complete name="clks" input="clb.clk" output="fle[9:0].clk">
        </complete>
        <complete name="resets" input="clb.reset" output="fle[9:0].reset">
        </complete>
        <complete name="sets" input="clb.set" output="fle[9:0].set">
        </complete>
        <!-- This way of specifying direct connection to clb outputs is important because this architecture uses automatic spreading of opins.  
                 By grouping to output pins in this fashion, if a logic block is completely filled by 6-LUTs, 
                 then the outputs those 6-LUTs take get evenly distributed across all four sides of the CLB instead of clumped on two sides (which is what happens with a more
                 naive specification).
          -->
        <direct name="clbouts1" input="fle[9:0].out[0:0]" output="clb.O[9:0]"/>
        <direct name="clbouts2" input="fle[9:0].out[1:1]" output="clb.O[19:10]"/>
        <!-- Carry chain links -->
        <direct name="carry_in" input="clb.cin" output="fle[0:0].cin">
          <!-- Put all inter-block carry chain delay on this one edge -->
          <delay_constant max="0.16e-9" in_port="clb.cin" out_port="fle[0:0].cin"/>
          <pack_pattern name="chain" in_port="clb.cin" out_port="fle[0:0].cin"/>
        </direct>
        <direct name="carry_out" input="fle[9:9].cout" output="clb.cout">
          <pack_pattern name="chain" in_port="fle[9:9].cout" out_port="clb.cout"/>
        </direct>
        <direct name="carry_link" input="fle[8:0].cout" output="fle[9:1].cin">
          <pack_pattern name="chain" in_port="fle[8:0].cout" out_port="fle[9:1].cin"/>
        </direct>
      </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
    <!-- Define DSP slice begin -->
    <pb_type name="dsp_top">
      <input name="reset" num_pins="1" is_non_clock_global="true"/>
      <input name="dsp_I1" num_pins="64" />
      <input name="dsp_I2" num_pins="64" />
      <input name="chainin" num_pins="64"/>
      <input name="scanin" num_pins="27"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <clock name="clk" num_pins="1"/>

    <pb_type name="dsp" num_pb="1">
      <input name="reset" num_pins="1"/>
      <input name="dsp_I1" num_pins="64"/>
      <input name="dsp_I2" num_pins="64"/>
      <input name="chainin" num_pins="64"/>
      <input name="scanin" num_pins="27"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <clock name="clk" num_pins="1"/>

      <pb_type name="dsp_pb" num_pb="1">
        <input name="reset" num_pins="1"/>
        <input name="mode_sigs" num_pins="12"/>
        <input name="datain" num_pins="116"/>
        <input name="chainin" num_pins="64"/>
        <input name="scanin" num_pins="27"/>
        <output name="result" num_pins="74"/>
        <output name="chainout" num_pins="64"/>
        <output name="scanout" num_pins="27"/>
        <clock name="clk" num_pins="1"/>

        <!-- fixed-point multiplier mode (1 27x27 multiplier) result = ax*ay -->
        <mode name="one_mult_27x27">
          <pb_type name="one_mult_27x27" num_pb="1">
            <input name="a" num_pins="27"/>
            <input name="b" num_pins="27"/>
            <output name="out" num_pins="54"/>
            <pb_type name="mult_27x27" blif_model=".subckt multiply" num_pb="1">
              <input name="a" num_pins="27"/>
              <input name="b" num_pins="27"/>
              <output name="out" num_pins="54"/>
              <delay_constant max="2.14e-9" in_port="mult_27x27.a" out_port="mult_27x27.out"/>
              <delay_constant max="2.14e-9" in_port="mult_27x27.b" out_port="mult_27x27.out"/>
            </pb_type>
            <interconnect>
              <direct name="a2a" input="one_mult_27x27.a" output="mult_27x27.a">
              </direct>
              <direct name="b2b" input="one_mult_27x27.b" output="mult_27x27.b">
              </direct>
              <direct name="out2out" input="mult_27x27.out" output="one_mult_27x27.out">
              </direct>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="datain2a" input="dsp_pb.datain[26:0]" output="one_mult_27x27.a">
            </direct>
            <direct name="datain2b" input="dsp_pb.datain[53:27]" output="one_mult_27x27.b">
            </direct>
            <direct name="out2dataout" input="one_mult_27x27.out" output="dsp_pb.result[53:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier mode (2 18x19 multipliers) result[some:bits] = ax*ay, result[other:bits] = bx*by -->
        <mode name="two_mult_18x19">
          <pb_type name="two_mult_18x19" num_pb="2">
            <input name="a" num_pins="18"/>
            <input name="b" num_pins="19"/>
            <output name="out" num_pins="37"/>
            <pb_type name="mult_18x19" blif_model=".subckt multiply" num_pb="1">
              <input name="a" num_pins="18"/>
              <input name="b" num_pins="19"/>
              <output name="out" num_pins="37"/>
              <delay_constant max="2.14e-9" in_port="mult_18x19.a" out_port="mult_18x19.out"/>
              <delay_constant max="2.14e-9" in_port="mult_18x19.b" out_port="mult_18x19.out"/>
            </pb_type>
            <interconnect>
              <direct name="a2a" input="two_mult_18x19.a" output="mult_18x19.a">
                 </direct>
              <direct name="b2b" input="two_mult_18x19.b" output="mult_18x19.b">
                 </direct>
              <direct name="out2out" input="mult_18x19.out" output="two_mult_18x19.out">
                 </direct>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="datain2a1" input="dsp_pb.datain[17:0]" output="two_mult_18x19[0].a">
            </direct>
            <direct name="datain2b1" input="dsp_pb.datain[36:18]" output="two_mult_18x19[0].b">
            </direct>
            <direct name="datain2a2" input="dsp_pb.datain[54:37]" output="two_mult_18x19[1].a">
            </direct>
            <direct name="datain2b2" input="dsp_pb.datain[73:55]" output="two_mult_18x19[1].b">
            </direct>
            <direct name="out2result" input="two_mult_18x19.out" output="dsp_pb.result[73:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- Fixed point multiplier mode (4 9x9 multipliers) result = ax*ay -->
        <mode name="mult_9x9_fixed_pt_mode">
          <pb_type name="mult_9x9_fixed_pt" blif_model=".subckt multiply" num_pb="4">
            <input name="a" num_pins="9"/>
            <input name="b" num_pins="9"/>
            <output name="out" num_pins="18"/>

            <delay_constant max="2.14e-9" in_port="mult_9x9_fixed_pt.a" out_port="mult_9x9_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mult_9x9_fixed_pt.b" out_port="mult_9x9_fixed_pt.out"/>
          </pb_type>
          <interconnect>
            <direct name="atoa0" input="dsp_pb.datain[8:0]" output="mult_9x9_fixed_pt[0].a"/>
            <direct name="btob0" input="dsp_pb.datain[17:9]" output="mult_9x9_fixed_pt[0].b"/>
            <direct name="atoa1" input="dsp_pb.datain[26:18]" output="mult_9x9_fixed_pt[1].a"/>
            <direct name="btob1" input="dsp_pb.datain[35:27]" output="mult_9x9_fixed_pt[1].b"/>
            <direct name="atoa2" input="dsp_pb.datain[44:36]" output="mult_9x9_fixed_pt[2].a"/>
            <direct name="btob2" input="dsp_pb.datain[53:45]" output="mult_9x9_fixed_pt[2].b"/>
            <direct name="atoa3" input="dsp_pb.datain[62:54]" output="mult_9x9_fixed_pt[3].a"/>
            <direct name="btob3" input="dsp_pb.datain[71:63]" output="mult_9x9_fixed_pt[3].b"/>
            <direct name="sumouttosumout0" input="mult_9x9_fixed_pt[0].out" output="dsp_pb.result[17:0]"/>
            <direct name="sumouttosumout1" input="mult_9x9_fixed_pt[1].out" output="dsp_pb.result[35:18]"/>
            <direct name="sumouttosumout2" input="mult_9x9_fixed_pt[2].out" output="dsp_pb.result[53:36]"/>
            <direct name="sumouttosumout3" input="mult_9x9_fixed_pt[3].out" output="dsp_pb.result[71:54]"/>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier-add-sum mode result = (bx * by) + (ax * ay) + chainin. chainout = result -->
        <mode name="sop_2_mode">
          <pb_type name="sop_2" num_pb="1" blif_model=".subckt int_sop_2">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="ax" num_pins="18"/>
            <input name="ay" num_pins="19"/>
            <input name="bx" num_pins="18"/>
            <input name="by" num_pins="19"/>
            <input name="chainin" num_pins="37"/>
            <output name="result" num_pins="37"/>
            <output name="chainout" num_pins="37"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="sop_2.reset" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.mode_sigs" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.ax" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.ay" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.bx" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.by" out_port="sop_2.result"/>
            <delay_constant max="2.14e-9" in_port="sop_2.chainin" out_port="sop_2.result"/>

            <delay_constant max="2.14e-9" in_port="sop_2.reset" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.mode_sigs" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.ax" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.ay" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.bx" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.by" out_port="sop_2.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_2.chainin" out_port="sop_2.chainout"/>

            <T_setup value="66e-12" port="sop_2.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.ax" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.ay" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.bx" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.by" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.chainin" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.reset" clock="clk"/>
            <T_setup value="66e-12" port="sop_2.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.ax" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.ay" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.bx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.by" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_2.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="sop_2.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="sop_2.reset">
            </direct>
            <direct name="modesigs" input="dsp_pb.mode_sigs" output="sop_2.mode_sigs">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[17:0]" output="sop_2.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[36:18]" output="sop_2.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[54:37]" output="sop_2.bx">
            </direct>
            <direct name="datain2by" input="dsp_pb.datain[73:55]" output="sop_2.by">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[36:0]" output="sop_2.chainin">
            </direct>
            <direct name="dataout2result" input="sop_2.result" output="dsp_pb.result[36:0]">
            </direct>
            <direct name="chainout" input="sop_2.chainout" output="dsp_pb.chainout[36:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier-add-sum mode result = (ax * ay) + bx + chainin. chainout = result. with scanin-scanout support -->
        <mode name="mult_add_mode_18_19_36">
          <pb_type name="mult_add" num_pb="1" blif_model=".subckt mult_add_int_18x19">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="ax" num_pins="18"/>
            <input name="ay" num_pins="19"/>
            <input name="bx" num_pins="36"/>
            <input name="chainin" num_pins="64"/>
            <input name="scanin" num_pins="19"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <output name="scanout" num_pins="19"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.result"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.chainout"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.scanout"/>

            <T_setup value="66e-12" port="mult_add.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.ax" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.ay" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.bx" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.chainin" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.scanin" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.reset" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.ax" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.ay" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.bx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.scanin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="mult_add.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="mult_add.reset">
            </direct>
            <direct name="modesigs" input="dsp_pb.mode_sigs" output="mult_add.mode_sigs">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[17:0]" output="mult_add.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[36:18]" output="mult_add.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[72:37]" output="mult_add.bx">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="mult_add.chainin">
            </direct>
            <direct name="scanin"   input="dsp_pb.scanin[18:0]" output="mult_add.scanin">
            </direct>
            <direct name="dataout2result" input="mult_add.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="mult_add.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
            <direct name="scanout" input="mult_add.scanout" output="dsp_pb.scanout[18:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier-add-sum mode result = (ax * ay) + bx + chainin. chainout = result. with scanin-scanout support -->
        <mode name="mult_add_mode_27_27_64">
          <pb_type name="mult_add" num_pb="1" blif_model=".subckt mult_add_int_27x27">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="ax" num_pins="27"/>
            <input name="ay" num_pins="27"/>
            <input name="bx" num_pins="36"/>
            <input name="chainin" num_pins="64"/>
            <input name="scanin" num_pins="27"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <output name="scanout" num_pins="27"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.result"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.result"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.chainout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.chainout"/>

            <delay_constant max="2.14e-9" in_port="mult_add.reset" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.mode_sigs" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ax" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.ay" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.bx" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.chainin" out_port="mult_add.scanout"/>
            <delay_constant max="2.14e-9" in_port="mult_add.scanin" out_port="mult_add.scanout"/>

            <T_setup value="66e-12" port="mult_add.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.ax" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.ay" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.bx" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.chainin" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.scanin" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.reset" clock="clk"/>
            <T_setup value="66e-12" port="mult_add.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.ax" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.ay" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.bx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.scanin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="mult_add.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="mult_add.reset">
            </direct>
            <direct name="modesigs" input="dsp_pb.mode_sigs" output="mult_add.mode_sigs">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[26:0]" output="mult_add.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[53:27]" output="mult_add.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[89:54]" output="mult_add.bx">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="mult_add.chainin">
            </direct>
            <direct name="scanin"   input="dsp_pb.scanin[26:0]" output="mult_add.scanin">
            </direct>
            <direct name="dataout2result" input="mult_add.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="mult_add.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
            <direct name="scanout" input="mult_add.scanout" output="dsp_pb.scanout[26:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point sum-of-4 mode result = (dx * dy) + (cx * cy) + (bx * by) + (ax * ay) + chainin. chainout = result -->
        <mode name="sop_4_mode">
          <pb_type name="sop_4" num_pb="1" blif_model=".subckt int_sop_4">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="ax" num_pins="9"/>
            <input name="ay" num_pins="9"/>
            <input name="bx" num_pins="9"/>
            <input name="by" num_pins="9"/>
            <input name="cx" num_pins="9"/>
            <input name="cy" num_pins="9"/>
            <input name="dx" num_pins="9"/>
            <input name="dy" num_pins="9"/>
            <input name="chainin" num_pins="64"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="sop_4.reset" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.mode_sigs" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ax" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ay" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.bx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.by" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cy" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dy" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.chainin" out_port="sop_4.result"/>

            <delay_constant max="2.14e-9" in_port="sop_4.reset" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.mode_sigs" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ax" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ay" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.bx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.by" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cy" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dy" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.chainin" out_port="sop_4.chainout"/>

            <T_setup value="66e-12" port="sop_4.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.ax" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.ay" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.bx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.by" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.cx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.cy" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.dx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.dy" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.chainin" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.reset" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.ax" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.ay" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.bx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.by" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.cx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.cy" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.dx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.dy" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="sop_4.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="sop_4.reset">
            </direct>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="sop_4.mode_sigs">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[8:0]" output="sop_4.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[17:9]" output="sop_4.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[26:18]" output="sop_4.bx">
            </direct>
            <direct name="datain2by" input="dsp_pb.datain[35:27]" output="sop_4.by">
            </direct>
            <direct name="datain2cx" input="dsp_pb.datain[44:36]" output="sop_4.cx">
            </direct>
            <direct name="datain2cy" input="dsp_pb.datain[53:45]" output="sop_4.cy">
            </direct>
            <direct name="datain2dx" input="dsp_pb.datain[62:54]" output="sop_4.dx">
            </direct>
            <direct name="datain2dy" input="dsp_pb.datain[71:63]" output="sop_4.dy">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="sop_4.chainin">
            </direct>
            <direct name="dataout2result" input="sop_4.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="sop_4.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point sum-of-4 accum mode result = (dx * dy) + (cx * cy) + (bx * by) + (ax * ay) + chainin + accumulator. chainout = result -->
        <mode name="sop_4_accum_mode">
          <pb_type name="sop_4" num_pb="1" blif_model=".subckt int_sop_accum_4">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="ax" num_pins="9"/>
            <input name="ay" num_pins="9"/>
            <input name="bx" num_pins="9"/>
            <input name="by" num_pins="9"/>
            <input name="cx" num_pins="9"/>
            <input name="cy" num_pins="9"/>
            <input name="dx" num_pins="9"/>
            <input name="dy" num_pins="9"/>
            <input name="chainin" num_pins="64"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="sop_4.mode_sigs" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ax" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ay" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.bx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.by" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cy" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dx" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dy" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.chainin" out_port="sop_4.result"/>
            <delay_constant max="2.14e-9" in_port="sop_4.reset" out_port="sop_4.result"/>

            <delay_constant max="2.14e-9" in_port="sop_4.mode_sigs" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ax" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.ay" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.bx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.by" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.cy" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dx" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.dy" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.chainin" out_port="sop_4.chainout"/>
            <delay_constant max="2.14e-9" in_port="sop_4.reset" out_port="sop_4.chainout"/>

            <T_setup value="66e-12" port="sop_4.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.ax" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.ay" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.bx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.by" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.cx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.cy" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.dx" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.dy" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.chainin" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.reset" clock="clk"/>
            <T_setup value="66e-12" port="sop_4.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.ax" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.ay" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.bx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.by" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.cx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.cy" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.dx" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.dy" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="sop_4.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="sop_4.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="sop_4.reset">
            </direct>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="sop_4.mode_sigs">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[8:0]" output="sop_4.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[17:9]" output="sop_4.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[26:18]" output="sop_4.bx">
            </direct>
            <direct name="datain2by" input="dsp_pb.datain[35:27]" output="sop_4.by">
            </direct>
            <direct name="datain2cx" input="dsp_pb.datain[44:36]" output="sop_4.cx">
            </direct>
            <direct name="datain2cy" input="dsp_pb.datain[53:45]" output="sop_4.cy">
            </direct>
            <direct name="datain2dx" input="dsp_pb.datain[62:54]" output="sop_4.dx">
            </direct>
            <direct name="datain2dy" input="dsp_pb.datain[71:63]" output="sop_4.dy">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="sop_4.chainin">
            </direct>
            <direct name="dataout2result" input="sop_4.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="sop_4.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- Fixed point mac mode (result = a*b + accumulated value-->
        <mode name="mac_27x27_fixed_pt_mode">
          <pb_type name="mac_27x27_fixed_pt" blif_model=".subckt mac_int_27x27" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="a" num_pins="27"/>
            <input name="b" num_pins="27"/>
            <output name="out" num_pins="54"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="mac_27x27_fixed_pt.a" out_port="mac_27x27_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_27x27_fixed_pt.b" out_port="mac_27x27_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_27x27_fixed_pt.reset" out_port="mac_27x27_fixed_pt.out"/>

            <T_setup value="66e-12" port="mac_27x27_fixed_pt.reset" clock="clk"/>
            <T_setup value="66e-12" port="mac_27x27_fixed_pt.a" clock="clk"/>
            <T_setup value="66e-12" port="mac_27x27_fixed_pt.b" clock="clk"/>
            <T_setup value="66e-12" port="mac_27x27_fixed_pt.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_27x27_fixed_pt.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_27x27_fixed_pt.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_27x27_fixed_pt.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_27x27_fixed_pt.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="mac_27x27_fixed_pt.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="mac_27x27_fixed_pt.clk"/>
            <direct name="atoa" input="dsp_pb.datain[26:0]" output="mac_27x27_fixed_pt.a"/>
            <direct name="btob" input="dsp_pb.datain[53:27]" output="mac_27x27_fixed_pt.b"/>
            <direct name="sumouttosumout" input="mac_27x27_fixed_pt.out" output="dsp_pb.result[53:0]"/>
          </interconnect>
        </mode>

        <!-- Fixed point mac mode (result = a*b + accumulated value-->
        <mode name="mac_18x19_fixed_pt_mode">
          <pb_type name="mac_fixed_pt" blif_model=".subckt mac_int_18x19" num_pb="2">
            <input name="reset" num_pins="1"/>
            <input name="a" num_pins="18"/>
            <input name="b" num_pins="19"/>
            <output name="out" num_pins="37"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="mac_fixed_pt.a" out_port="mac_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_fixed_pt.b" out_port="mac_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_fixed_pt.reset" out_port="mac_fixed_pt.out"/>

            <T_setup value="66e-12" port="mac_fixed_pt.reset" clock="clk"/>
            <T_setup value="66e-12" port="mac_fixed_pt.a" clock="clk"/>
            <T_setup value="66e-12" port="mac_fixed_pt.b" clock="clk"/>
            <T_setup value="66e-12" port="mac_fixed_pt.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fixed_pt.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fixed_pt.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fixed_pt.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fixed_pt.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset0" input="dsp_pb.reset" output="mac_fixed_pt[0].reset"/>
            <direct name="reset1" input="dsp_pb.reset" output="mac_fixed_pt[1].reset"/>
            <direct name="clk0" input="dsp_pb.clk" output="mac_fixed_pt[0].clk"/>
            <direct name="clk1" input="dsp_pb.clk" output="mac_fixed_pt[1].clk"/>
            <direct name="atoa0" input="dsp_pb.datain[17:0]" output="mac_fixed_pt[0].a"/>
            <direct name="btob0" input="dsp_pb.datain[36:18]" output="mac_fixed_pt[0].b"/>
            <direct name="atoa1" input="dsp_pb.datain[54:37]" output="mac_fixed_pt[1].a"/>
            <direct name="btob1" input="dsp_pb.datain[73:55]" output="mac_fixed_pt[1].b"/>
            <direct name="sumouttosumout0" input="mac_fixed_pt[0].out" output="dsp_pb.result[36:0]"/>
            <direct name="sumouttosumout1" input="mac_fixed_pt[1].out" output="dsp_pb.result[73:37]"/>
          </interconnect>
        </mode>

        <!-- Fixed point mac mode (result = a*b + accumulated value-->
        <mode name="mac_9x9_fixed_pt_mode">
          <pb_type name="mac_9x9_fixed_pt" blif_model=".subckt mac_int_9x9" num_pb="4">
            <input name="reset" num_pins="1"/>
            <input name="a" num_pins="9"/>
            <input name="b" num_pins="9"/>
            <output name="out" num_pins="18"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="2.14e-9" in_port="mac_9x9_fixed_pt.a" out_port="mac_9x9_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_9x9_fixed_pt.b" out_port="mac_9x9_fixed_pt.out"/>
            <delay_constant max="2.14e-9" in_port="mac_9x9_fixed_pt.reset" out_port="mac_9x9_fixed_pt.out"/>

            <T_setup value="66e-12" port="mac_9x9_fixed_pt.reset" clock="clk"/>
            <T_setup value="66e-12" port="mac_9x9_fixed_pt.a" clock="clk"/>
            <T_setup value="66e-12" port="mac_9x9_fixed_pt.b" clock="clk"/>
            <T_setup value="66e-12" port="mac_9x9_fixed_pt.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_9x9_fixed_pt.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_9x9_fixed_pt.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_9x9_fixed_pt.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_9x9_fixed_pt.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset0" input="dsp_pb.reset" output="mac_9x9_fixed_pt[0].reset"/>
            <direct name="reset1" input="dsp_pb.reset" output="mac_9x9_fixed_pt[1].reset"/>
            <direct name="reset2" input="dsp_pb.reset" output="mac_9x9_fixed_pt[2].reset"/>
            <direct name="reset3" input="dsp_pb.reset" output="mac_9x9_fixed_pt[3].reset"/>
            <direct name="clk0" input="dsp_pb.clk" output="mac_9x9_fixed_pt[0].clk"/>
            <direct name="clk1" input="dsp_pb.clk" output="mac_9x9_fixed_pt[1].clk"/>
            <direct name="clk2" input="dsp_pb.clk" output="mac_9x9_fixed_pt[2].clk"/>
            <direct name="clk3" input="dsp_pb.clk" output="mac_9x9_fixed_pt[3].clk"/>
            <direct name="atoa0" input="dsp_pb.datain[8:0]" output="mac_9x9_fixed_pt[0].a"/>
            <direct name="btob0" input="dsp_pb.datain[17:9]" output="mac_9x9_fixed_pt[0].b"/>
            <direct name="atoa1" input="dsp_pb.datain[26:18]" output="mac_9x9_fixed_pt[1].a"/>
            <direct name="btob1" input="dsp_pb.datain[35:27]" output="mac_9x9_fixed_pt[1].b"/>
            <direct name="atoa2" input="dsp_pb.datain[44:36]" output="mac_9x9_fixed_pt[2].a"/>
            <direct name="btob2" input="dsp_pb.datain[53:45]" output="mac_9x9_fixed_pt[2].b"/>
            <direct name="atoa3" input="dsp_pb.datain[62:54]" output="mac_9x9_fixed_pt[3].a"/>
            <direct name="btob3" input="dsp_pb.datain[71:63]" output="mac_9x9_fixed_pt[3].b"/>
            <direct name="sumouttosumout0" input="mac_9x9_fixed_pt[0].out" output="dsp_pb.result[17:0]"/>
            <direct name="sumouttosumout1" input="mac_9x9_fixed_pt[1].out" output="dsp_pb.result[35:18]"/>
            <direct name="sumouttosumout2" input="mac_9x9_fixed_pt[2].out" output="dsp_pb.result[53:36]"/>
            <direct name="sumouttosumout3" input="mac_9x9_fixed_pt[3].out" output="dsp_pb.result[71:54]"/>
          </interconnect>
        </mode>

        <!-- floating point multiplier mode (result = a * b)-->
        <mode name="mult_fp32_mode">
          <pb_type name="mult_fp32" blif_model=".subckt mult_fp_32" num_pb="1">
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <output name="out" num_pins="32"/>

            <delay_constant max="3.417e-9" in_port="mult_fp32.a" out_port="mult_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="mult_fp32.b" out_port="mult_fp32.out"/>
          </pb_type>
          <interconnect>
            <direct name="a2a" input="dsp_pb.datain[31:0]" output="mult_fp32.a">
            </direct>
            <direct name="b2b" input="dsp_pb.datain[63:32]" output="mult_fp32.b">
            </direct>
            <direct name="out2out" input="mult_fp32.out" output="dsp_pb.result[31:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- floating point multiplier mode (result = a * b)-->
        <mode name="mult_fp16_mode">
          <pb_type name="mult_fp16" blif_model=".subckt mult_fp_16" num_pb="2">
            <input name="a" num_pins="16"/>
            <input name="b" num_pins="16"/>
            <output name="out" num_pins="16"/>

            <delay_constant max="3.417e-9" in_port="mult_fp16.a" out_port="mult_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="mult_fp16.b" out_port="mult_fp16.out"/>
          </pb_type>
          <interconnect>
            <direct name="a2a0" input="dsp_pb.datain[15:0]" output="mult_fp16[0].a"></direct>
            <direct name="a2a1" input="dsp_pb.datain[31:16]" output="mult_fp16[1].a"></direct>
            <direct name="b2b0" input="dsp_pb.datain[47:32]" output="mult_fp16[0].b"></direct>
            <direct name="b2b1" input="dsp_pb.datain[63:48]" output="mult_fp16[1].b"></direct>
            <direct name="out2out0" input="mult_fp16[0].out" output="dsp_pb.result[15:0]"></direct>
            <direct name="out2out1" input="mult_fp16[1].out" output="dsp_pb.result[31:16]"></direct>
          </interconnect>
        </mode>

        <!-- floating point adder mode (result = a + b)-->
        <mode name="adder_fp32_mode"> 
          <pb_type name="adder_fp32" blif_model=".subckt addition_fp_32" num_pb="1">
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <output name="out" num_pins="32"/>

            <delay_constant max="3.417e-9" in_port="adder_fp32.a" out_port="adder_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="adder_fp32.b" out_port="adder_fp32.out"/>
          </pb_type>
          <interconnect>
            <direct name="atoa" input="dsp_pb.datain[31:0]" output="adder_fp32.a">
            </direct>
            <direct name="btob" input="dsp_pb.datain[63:32]" output="adder_fp32.b">
            </direct>
            <direct name="sumouttosumout" input="adder_fp32.out" output="dsp_pb.result[31:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- floating point adder mode (result = a + b)-->
        <mode name="adder_fp16_mode">
          <pb_type name="adder_fp16" blif_model=".subckt addition_fp_16" num_pb="2">
            <input name="a" num_pins="16"/>
            <input name="b" num_pins="16"/>
            <output name="out" num_pins="16"/>

            <delay_constant max="3.417e-9" in_port="adder_fp16.a" out_port="adder_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="adder_fp16.b" out_port="adder_fp16.out"/>
          </pb_type>
          <interconnect>
            <direct name="a2a0" input="dsp_pb.datain[15:0]" output="adder_fp16[0].a"></direct>
            <direct name="a2a1" input="dsp_pb.datain[31:16]" output="adder_fp16[1].a"></direct>
            <direct name="b2b0" input="dsp_pb.datain[47:32]" output="adder_fp16[0].b"></direct>
            <direct name="b2b1" input="dsp_pb.datain[63:48]" output="adder_fp16[1].b"></direct>
            <direct name="out2out0" input="adder_fp16[0].out" output="dsp_pb.result[15:0]"></direct>
            <direct name="out2out1" input="adder_fp16[1].out" output="dsp_pb.result[31:16]"></direct>
          </interconnect>
        </mode>

        <!-- clocked floating point multiplier mode (result = a * b)-->
        <mode name="mult_fp32_clocked_mode">
          <pb_type name="mult_fp32" blif_model=".subckt mult_fp_clk_32" num_pb="1">
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <output name="out" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="mult_fp32.a" out_port="mult_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="mult_fp32.b" out_port="mult_fp32.out"/>

            <T_setup value="66e-12" port="mult_fp32.a" clock="clk"/>
            <T_setup value="66e-12" port="mult_fp32.b" clock="clk"/>
            <T_setup value="66e-12" port="mult_fp32.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp32.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp32.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp32.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="mult_fp32.clk"/>
            <direct name="a2a" input="dsp_pb.datain[31:0]" output="mult_fp32.a">
            </direct>
            <direct name="b2b" input="dsp_pb.datain[63:32]" output="mult_fp32.b">
            </direct>
            <direct name="out2out" input="mult_fp32.out" output="dsp_pb.result[31:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- clocked floating point multiplier mode (result = a * b)-->
        <mode name="mult_fp16_clocked_mode">
          <pb_type name="mult_fp16" blif_model=".subckt mult_fp_clk_16" num_pb="2">
            <input name="a" num_pins="16"/>
            <input name="b" num_pins="16"/>
            <output name="out" num_pins="16"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="mult_fp16.a" out_port="mult_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="mult_fp16.b" out_port="mult_fp16.out"/>

            <T_setup value="66e-12" port="mult_fp16.a" clock="clk"/>
            <T_setup value="66e-12" port="mult_fp16.b" clock="clk"/>
            <T_setup value="66e-12" port="mult_fp16.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp16.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp16.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mult_fp16.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk0" input="dsp_pb.clk" output="mult_fp16[0].clk"/>
            <direct name="clk1" input="dsp_pb.clk" output="mult_fp16[1].clk"/>
            <direct name="a2a0" input="dsp_pb.datain[15:0]" output="mult_fp16[0].a"></direct>
            <direct name="a2a1" input="dsp_pb.datain[31:16]" output="mult_fp16[1].a"></direct>
            <direct name="b2b0" input="dsp_pb.datain[47:32]" output="mult_fp16[0].b"></direct>
            <direct name="b2b1" input="dsp_pb.datain[63:48]" output="mult_fp16[1].b"></direct>
            <direct name="out2out0" input="mult_fp16[0].out" output="dsp_pb.result[15:0]"></direct>
            <direct name="out2out1" input="mult_fp16[1].out" output="dsp_pb.result[31:16]"></direct>
          </interconnect>
        </mode>

        <!-- clocked floating point adder mode (result = a + b)-->
        <mode name="adder_fp32_clocked_mode"> 
          <pb_type name="adder_fp32" blif_model=".subckt addition_fp_clk_32" num_pb="1">
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <output name="out" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="adder_fp32.a" out_port="adder_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="adder_fp32.b" out_port="adder_fp32.out"/>

            <T_setup value="66e-12" port="adder_fp32.a" clock="clk"/>
            <T_setup value="66e-12" port="adder_fp32.b" clock="clk"/>
            <T_setup value="66e-12" port="adder_fp32.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp32.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp32.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp32.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="adder_fp32.clk"/>
            <direct name="atoa" input="dsp_pb.datain[31:0]" output="adder_fp32.a">
            </direct>
            <direct name="btob" input="dsp_pb.datain[63:32]" output="adder_fp32.b">
            </direct>
            <direct name="sumouttosumout" input="adder_fp32.out" output="dsp_pb.result[31:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- clocked floating point adder mode (result = a + b)-->
        <mode name="adder_fp16_clocked_mode">
          <pb_type name="adder_fp16" blif_model=".subckt addition_fp_clk_16" num_pb="2">
            <input name="a" num_pins="16"/>
            <input name="b" num_pins="16"/>
            <output name="out" num_pins="16"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="adder_fp16.a" out_port="adder_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="adder_fp16.b" out_port="adder_fp16.out"/>

            <T_setup value="66e-12" port="adder_fp16.a" clock="clk"/>
            <T_setup value="66e-12" port="adder_fp16.b" clock="clk"/>
            <T_setup value="66e-12" port="adder_fp16.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp16.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp16.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="adder_fp16.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk0" input="dsp_pb.clk" output="adder_fp16[0].clk"/>
            <direct name="clk1" input="dsp_pb.clk" output="adder_fp16[1].clk"/>
            <direct name="a2a0" input="dsp_pb.datain[15:0]" output="adder_fp16[0].a"></direct>
            <direct name="a2a1" input="dsp_pb.datain[31:16]" output="adder_fp16[1].a"></direct>
            <direct name="b2b0" input="dsp_pb.datain[47:32]" output="adder_fp16[0].b"></direct>
            <direct name="b2b1" input="dsp_pb.datain[63:48]" output="adder_fp16[1].b"></direct>
            <direct name="out2out0" input="adder_fp16[0].out" output="dsp_pb.result[15:0]"></direct>
            <direct name="out2out1" input="adder_fp16[1].out" output="dsp_pb.result[31:16]"></direct>
          </interconnect>
        </mode>

        <!-- floating point mac mode (result = a*b + accumulated value-->
        <mode name="mac_fp32_mode">
          <pb_type name="mac_fp32" blif_model=".subckt mac_fp_32" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <output name="out" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="mac_fp32.a" out_port="mac_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="mac_fp32.b" out_port="mac_fp32.out"/>
            <delay_constant max="3.417e-9" in_port="mac_fp32.reset" out_port="mac_fp32.out"/>

            <T_setup value="66e-12" port="mac_fp32.reset" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp32.a" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp32.b" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp32.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp32.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp32.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp32.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp32.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="mac_fp32.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="mac_fp32.clk"/>
            <direct name="atoa" input="dsp_pb.datain[31:0]" output="mac_fp32.a">
            </direct>
            <direct name="btob" input="dsp_pb.datain[63:32]" output="mac_fp32.b">
            </direct>
            <direct name="sumouttosumout" input="mac_fp32.out" output="dsp_pb.result[31:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- floating point 16-bit mac mode (result = a*b + accumulated value-->
        <mode name="mac_fp16_mode">
          <pb_type name="mac_fp16" blif_model=".subckt mac_fp_16" num_pb="2">
            <input name="reset" num_pins="1"/>
            <input name="a" num_pins="16"/>
            <input name="b" num_pins="16"/>
            <output name="out" num_pins="16"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="mac_fp16.a" out_port="mac_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="mac_fp16.b" out_port="mac_fp16.out"/>
            <delay_constant max="3.417e-9" in_port="mac_fp16.reset" out_port="mac_fp16.out"/>

            <T_setup value="66e-12" port="mac_fp16.reset" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp16.a" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp16.b" clock="clk"/>
            <T_setup value="66e-12" port="mac_fp16.out" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp16.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp16.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp16.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="mac_fp16.out" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset0" input="dsp_pb.reset" output="mac_fp16[0].reset"></direct>
            <direct name="reset1" input="dsp_pb.reset" output="mac_fp16[1].reset"></direct>
            <direct name="clk0" input="dsp_pb.clk" output="mac_fp16[0].clk"></direct>
            <direct name="clk1" input="dsp_pb.clk" output="mac_fp16[1].clk"></direct>
            <direct name="atoa0" input="dsp_pb.datain[15:0]"  output="mac_fp16[0].a"></direct>
            <direct name="atoa1" input="dsp_pb.datain[31:16]" output="mac_fp16[1].a"></direct>
            <direct name="btob0" input="dsp_pb.datain[47:32]" output="mac_fp16[0].b"></direct>
            <direct name="btob1" input="dsp_pb.datain[63:48]" output="mac_fp16[1].b"></direct>
            <direct name="sumouttosumout0" input="mac_fp16[0].out" output="dsp_pb.result[15:0]"></direct>
            <direct name="sumouttosumout1" input="mac_fp16[1].out" output="dsp_pb.result[31:16]"></direct>
          </interconnect>
        </mode>

        <!-- floating point fp16 sum-of-2 mult mode (result = fp16_mult_top_a * fp16_mult_top_b + fp16_mult_bot_a * fp16_mult_bot_b). chainout = third_inp or result-->
        <mode name="fp16_sum_of_products_mode"> 
          <pb_type name="fp16_sum_of_2_mult" blif_model=".subckt fp16_mult_add" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="top_a" num_pins="16"/>
            <input name="top_b" num_pins="16"/>
            <input name="bot_a" num_pins="16"/>
            <input name="bot_b" num_pins="16"/>
            <input name="fp32_in" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.reset" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.mode_sigs" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_a" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_b" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_a" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_b" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.fp32_in" out_port="fp16_sum_of_2_mult.result"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.reset" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.mode_sigs" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_a" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_b" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_a" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_b" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.fp32_in" out_port="fp16_sum_of_2_mult.chainout"/>

            <T_setup value="66e-12" port="fp16_sum_of_2_mult.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.top_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.top_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.bot_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.bot_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.top_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.top_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.bot_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.bot_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="fp16_sum_of_2_mult.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp16_sum_of_2_mult.clk"/>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp16_sum_of_2_mult.mode_sigs">
            </direct>
            <direct name="atoa_top" input="dsp_pb.datain[15:0]" output="fp16_sum_of_2_mult.top_a">
            </direct>
            <direct name="btob_top" input="dsp_pb.datain[31:16]" output="fp16_sum_of_2_mult.top_b">
            </direct>
            <direct name="result_top" input="fp16_sum_of_2_mult.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="atoa_bot" input="dsp_pb.datain[47:32]" output="fp16_sum_of_2_mult.bot_a">
            </direct>
            <direct name="btob_bot" input="dsp_pb.datain[63:48]" output="fp16_sum_of_2_mult.bot_b">
            </direct>
            <direct name="result_bot" input="fp16_sum_of_2_mult.result" output="dsp_pb.result[63:32]">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]" output="fp16_sum_of_2_mult.fp32_in">
            </direct>
            <direct name="chainout" input="fp16_sum_of_2_mult.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>  

        <!-- floating point fp16 sum-of-2 mult mode (result = fp16_mult_top_a * fp16_mult_top_b + fp16_mult_bot_a * fp16_mult_bot_b + fp32 chainin or third inp. chainout = third_inp or result)-->
        <mode name="fp16_sum_of_products_2_mult_mode"> 
          <pb_type name="fp16_sum_of_2_mult" blif_model=".subckt fp16_sop2_mult" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="top_a" num_pins="16"/>
            <input name="top_b" num_pins="16"/>
            <input name="bot_a" num_pins="16"/>
            <input name="bot_b" num_pins="16"/>
            <input name="fp32_in" num_pins="32"/>
            <input name="chainin" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.reset" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.mode_sigs" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_a" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_b" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_a" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_b" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.chainin" out_port="fp16_sum_of_2_mult.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.fp32_in" out_port="fp16_sum_of_2_mult.result"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.reset" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.mode_sigs" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_a" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.top_b" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_a" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.bot_b" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.chainin" out_port="fp16_sum_of_2_mult.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_mult.fp32_in" out_port="fp16_sum_of_2_mult.chainout"/>

            <T_setup value="66e-12" port="fp16_sum_of_2_mult.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.top_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.top_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.bot_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.bot_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.chainin" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_mult.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.top_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.top_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.bot_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.bot_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_mult.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="fp16_sum_of_2_mult.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp16_sum_of_2_mult.clk"/>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp16_sum_of_2_mult.mode_sigs">
            </direct>
            <direct name="atoa_top" input="dsp_pb.datain[15:0]" output="fp16_sum_of_2_mult.top_a">
            </direct>
            <direct name="btob_top" input="dsp_pb.datain[31:16]" output="fp16_sum_of_2_mult.top_b">
            </direct>
            <direct name="result_top" input="fp16_sum_of_2_mult.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="atoa_bot" input="dsp_pb.datain[47:32]" output="fp16_sum_of_2_mult.bot_a">
            </direct>
            <direct name="btob_bot" input="dsp_pb.datain[63:48]" output="fp16_sum_of_2_mult.bot_b">
            </direct>
            <direct name="result_bot" input="fp16_sum_of_2_mult.result" output="dsp_pb.result[63:32]">
            </direct>
            <direct name="chainin" input="dsp_pb.chainin[31:0]" output="fp16_sum_of_2_mult.chainin">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]" output="fp16_sum_of_2_mult.fp32_in">
            </direct>
            <direct name="chainout" input="fp16_sum_of_2_mult.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>        

        <!-- floating point fp16 sum-of-2 accum mode (result = fp16_mult_top_a * fp16_mult_top_b + fp16_mult_bot_a * fp16_mult_bot_b + accumulator. chainout = result)-->
        <mode name="fp16_sum_of_products_2_accum_mode"> 
          <pb_type name="fp16_sum_of_2_accum" blif_model=".subckt fp16_sop2_accum" num_pb="1">
            <input name="mode_sigs" num_pins="12"/>
            <input name="reset" num_pins="1"/>
            <input name="top_a" num_pins="16"/>
            <input name="top_b" num_pins="16"/>
            <input name="bot_a" num_pins="16"/>
            <input name="bot_b" num_pins="16"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.mode_sigs" out_port="fp16_sum_of_2_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.top_a" out_port="fp16_sum_of_2_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.top_b" out_port="fp16_sum_of_2_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.bot_a" out_port="fp16_sum_of_2_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.bot_b" out_port="fp16_sum_of_2_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.reset" out_port="fp16_sum_of_2_accum.result"/>

            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.mode_sigs" out_port="fp16_sum_of_2_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.top_a" out_port="fp16_sum_of_2_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.top_b" out_port="fp16_sum_of_2_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.bot_a" out_port="fp16_sum_of_2_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.bot_b" out_port="fp16_sum_of_2_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_sum_of_2_accum.reset" out_port="fp16_sum_of_2_accum.chainout"/>

            <T_setup value="66e-12" port="fp16_sum_of_2_accum.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.top_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.top_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.bot_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.bot_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp16_sum_of_2_accum.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.top_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.top_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.bot_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.bot_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_sum_of_2_accum.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp16_sum_of_2_accum.mode_sigs"/>
            <direct name="reset" input="dsp_pb.reset" output="fp16_sum_of_2_accum.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp16_sum_of_2_accum.clk"/>
            <direct name="atoa_top" input="dsp_pb.datain[15:0]" output="fp16_sum_of_2_accum.top_a">
            </direct>
            <direct name="btob_top" input="dsp_pb.datain[31:16]" output="fp16_sum_of_2_accum.top_b">
            </direct>
            <direct name="result_top" input="fp16_sum_of_2_accum.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="atoa_bot" input="dsp_pb.datain[47:32]" output="fp16_sum_of_2_accum.bot_a">
            </direct>
            <direct name="btob_bot" input="dsp_pb.datain[63:48]" output="fp16_sum_of_2_accum.bot_b">
            </direct>
            <direct name="result_bot" input="fp16_sum_of_2_accum.result" output="dsp_pb.result[63:32]">
            </direct>
            <direct name="chainout" input="fp16_sum_of_2_accum.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>        

        <!-- floating point fp16 mult, fp32 add mode (chainout = fp16_mult_top_a * fp16_mult_top_b + fp16_mult_bot_a * fp16_mult_bot_b. result = chainin + third_inp)-->
        <mode name="fp16_mult_fp32_add"> 
          <pb_type name="fp16_mult_fp32_add" blif_model=".subckt fp16_mult_fp32_add" num_pb="1">
            <input name="mode_sigs" num_pins="12"/>
            <input name="reset" num_pins="1"/>
            <input name="top_a" num_pins="16"/>
            <input name="top_b" num_pins="16"/>
            <input name="bot_a" num_pins="16"/>
            <input name="bot_b" num_pins="16"/>
            <input name="fp32_in" num_pins="32"/>
            <input name="chainin" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.reset" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.mode_sigs" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.top_a" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.top_b" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.bot_a" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.bot_b" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.chainin" out_port="fp16_mult_fp32_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.fp32_in" out_port="fp16_mult_fp32_add.result"/>

            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.reset" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.mode_sigs" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.top_a" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.top_b" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.bot_a" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.bot_b" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.chainin" out_port="fp16_mult_fp32_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_add.fp32_in" out_port="fp16_mult_fp32_add.chainout"/>

            <T_setup value="66e-12" port="fp16_mult_fp32_add.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.top_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.top_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.bot_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.bot_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.chainin" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_add.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.top_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.top_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.bot_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.bot_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="fp16_mult_fp32_add.clk"/>
            <direct name="reset" input="dsp_pb.reset" output="fp16_mult_fp32_add.reset"/>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp16_mult_fp32_add.mode_sigs">
            </direct>
            <direct name="atoa_top" input="dsp_pb.datain[15:0]" output="fp16_mult_fp32_add.top_a">
            </direct>
            <direct name="btob_top" input="dsp_pb.datain[31:16]" output="fp16_mult_fp32_add.top_b">
            </direct>
            <direct name="result_top" input="fp16_mult_fp32_add.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="atoa_bot" input="dsp_pb.datain[47:32]" output="fp16_mult_fp32_add.bot_a">
            </direct>
            <direct name="btob_bot" input="dsp_pb.datain[63:48]" output="fp16_mult_fp32_add.bot_b">
            </direct>
            <direct name="result_bot" input="fp16_mult_fp32_add.result" output="dsp_pb.result[63:32]">
            </direct>
            <direct name="chainin" input="dsp_pb.chainin[31:0]" output="fp16_mult_fp32_add.chainin">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]]" output="fp16_mult_fp32_add.fp32_in">
            </direct>
            <direct name="chainout" input="fp16_mult_fp32_add.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>      

        <!-- floating point fp16 mult, fp32 accum mode (chainout = fp16_mult_top_a * fp16_mult_top_b + fp16_mult_bot_a * fp16_mult_bot_b. result = third_inp + accumulator)-->
        <mode name="fp16_mult_fp32_accum"> 
          <pb_type name="fp16_mult_fp32_accum" blif_model=".subckt fp16_mult_fp32_accum" num_pb="1">
            <input name="mode_sigs" num_pins="12"/>
            <input name="reset" num_pins="1"/>
            <input name="top_a" num_pins="16"/>
            <input name="top_b" num_pins="16"/>
            <input name="bot_a" num_pins="16"/>
            <input name="bot_b" num_pins="16"/>
            <input name="fp32_in" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.mode_sigs" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.top_a" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.top_b" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.bot_a" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.bot_b" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.fp32_in" out_port="fp16_mult_fp32_accum.result"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.reset" out_port="fp16_mult_fp32_accum.result"/>

            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.mode_sigs" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.top_a" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.top_b" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.bot_a" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.bot_b" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.fp32_in" out_port="fp16_mult_fp32_accum.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp16_mult_fp32_accum.reset" out_port="fp16_mult_fp32_accum.chainout"/>

            <T_setup value="66e-12" port="fp16_mult_fp32_accum.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.top_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.top_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.bot_a" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.bot_b" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp16_mult_fp32_accum.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.top_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.top_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.bot_a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.bot_b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp16_mult_fp32_accum.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp16_mult_fp32_accum.mode_sigs"/>
            <direct name="reset" input="dsp_pb.reset" output="fp16_mult_fp32_accum.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp16_mult_fp32_accum.clk"/>
            <direct name="atoa_top" input="dsp_pb.datain[15:0]" output="fp16_mult_fp32_accum.top_a">
            </direct>
            <direct name="btob_top" input="dsp_pb.datain[31:16]" output="fp16_mult_fp32_accum.top_b">
            </direct>
            <direct name="result_top" input="fp16_mult_fp32_accum.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="atoa_bot" input="dsp_pb.datain[47:32]" output="fp16_mult_fp32_accum.bot_a">
            </direct>
            <direct name="btob_bot" input="dsp_pb.datain[63:48]" output="fp16_mult_fp32_accum.bot_b">
            </direct>
            <direct name="result_bot" input="fp16_mult_fp32_accum.result" output="dsp_pb.result[63:32]">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]" output="fp16_mult_fp32_accum.fp32_in">
            </direct>
            <direct name="chainout" input="fp16_mult_fp32_accum.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>      

        <!-- floating point fp32 mult_then_add mode (result = fp32_mult_a * fp32_mult_b + chainin. chainout = third_inp or result) -->
        <mode name="fp32_mult_then_add"> 
          <pb_type name="fp32_mult_then_add" blif_model=".subckt fp32_mult_then_add" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <input name="fp32_in" num_pins="32"/>
            <input name="chainin" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.reset" out_port="fp32_mult_then_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.mode_sigs" out_port="fp32_mult_then_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.a" out_port="fp32_mult_then_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.b" out_port="fp32_mult_then_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.chainin" out_port="fp32_mult_then_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.fp32_in" out_port="fp32_mult_then_add.result"/>

            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.reset" out_port="fp32_mult_then_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.mode_sigs" out_port="fp32_mult_then_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.a" out_port="fp32_mult_then_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.b" out_port="fp32_mult_then_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.chainin" out_port="fp32_mult_then_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_then_add.fp32_in" out_port="fp32_mult_then_add.chainout"/>

            <T_setup value="66e-12" port="fp32_mult_then_add.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.a" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.b" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.chainin" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_then_add.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_then_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="fp32_mult_then_add.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp32_mult_then_add.clk"/>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp32_mult_then_add.mode_sigs">
            </direct>
            <direct name="atoa" input="dsp_pb.datain[31:0]" output="fp32_mult_then_add.a">
            </direct>
            <direct name="btob" input="dsp_pb.datain[63:32]" output="fp32_mult_then_add.b">
            </direct>
            <direct name="result" input="fp32_mult_then_add.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="chainin" input="dsp_pb.chainin[31:0]" output="fp32_mult_then_add.chainin">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]]" output="fp32_mult_then_add.fp32_in">
            </direct>
            <direct name="chainout" input="fp32_mult_then_add.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>      

        <!-- floating point fp32 mult_add mode (chainout = fp32_mult_a * fp32_mult_b. chainout = third_inp + chainin)-->
        <mode name="fp32_mult_add"> 
          <pb_type name="fp32_mult_add" blif_model=".subckt fp32_mult_add" num_pb="1">
            <input name="reset" num_pins="1"/>
            <input name="mode_sigs" num_pins="12"/>
            <input name="a" num_pins="32"/>
            <input name="b" num_pins="32"/>
            <input name="fp32_in" num_pins="32"/>
            <input name="chainin" num_pins="32"/>
            <output name="result" num_pins="32"/>
            <output name="chainout" num_pins="32"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="3.417e-9" in_port="fp32_mult_add.reset" out_port="fp32_mult_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.mode_sigs" out_port="fp32_mult_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.a" out_port="fp32_mult_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.b" out_port="fp32_mult_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.chainin" out_port="fp32_mult_add.result"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.fp32_in" out_port="fp32_mult_add.result"/>

            <delay_constant max="3.417e-9" in_port="fp32_mult_add.reset" out_port="fp32_mult_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.mode_sigs" out_port="fp32_mult_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.a" out_port="fp32_mult_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.b" out_port="fp32_mult_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.chainin" out_port="fp32_mult_add.chainout"/>
            <delay_constant max="3.417e-9" in_port="fp32_mult_add.fp32_in" out_port="fp32_mult_add.chainout"/>

            <T_setup value="66e-12" port="fp32_mult_add.reset" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.mode_sigs" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.a" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.b" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.chainin" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.fp32_in" clock="clk"/>
            <T_setup value="66e-12" port="fp32_mult_add.result" clock="clk"/>

            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.reset" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.mode_sigs" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.a" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.b" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.chainin" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.fp32_in" clock="clk"/>
            <T_clock_to_Q max="124e-12" min="124e-12" port="fp32_mult_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="reset" input="dsp_pb.reset" output="fp32_mult_add.reset"/>
            <direct name="clk" input="dsp_pb.clk" output="fp32_mult_add.clk"/>
            <direct name="mode_sigs" input="dsp_pb.mode_sigs" output="fp32_mult_add.mode_sigs">
            </direct>
            <direct name="atoa" input="dsp_pb.datain[31:0]" output="fp32_mult_add.a">
            </direct>
            <direct name="btob" input="dsp_pb.datain[63:32]" output="fp32_mult_add.b">
            </direct>
            <direct name="result" input="fp32_mult_add.result" output="dsp_pb.result[31:0]">
            </direct>
            <direct name="chainin" input="dsp_pb.chainin[31:0]" output="fp32_mult_add.chainin">
            </direct>
            <direct name="fp32in" input="dsp_pb.datain[95:64]]" output="fp32_mult_add.fp32_in">
            </direct>
            <direct name="chainout" input="fp32_mult_add.chainout" output="dsp_pb.chainout[31:0]">
            </direct>
          </interconnect>
        </mode>      
      </pb_type>

      <interconnect>
        <direct name="mode_sigs" input="dsp.dsp_I1[11:0]" output ="dsp_pb.mode_sigs"/>
        <direct name="datain1" input="dsp.dsp_I1[63:12]" output ="dsp_pb.datain[51:0]"/>
        <direct name="datain2" input="dsp.dsp_I2" output ="dsp_pb.datain[115:52]"/>
        <direct name="reset" input="dsp.reset" output="dsp_pb.reset"></direct>
        <direct name="chainin" input="dsp.chainin"    output="dsp_pb.chainin"></direct>
        <direct name="chainout" input="dsp_pb.chainout" output="dsp.chainout"></direct>
        <direct name="scanin" input="dsp.scanin"    output="dsp_pb.scanin"></direct>
        <direct name="scanout" input="dsp_pb.scanout" output="dsp.scanout"></direct>
        <direct name="result" input="dsp_pb.result" output="dsp.result"></direct>
        <direct name="clk" input="dsp.clk" output="dsp_pb.clk"></direct>
      </interconnect>  

    </pb_type>
    <interconnect>
        <!--50% sparse crossbar means 50% of the lines can reach an actual input of the dsp 
        We do this by splitting inputs into two buckets and having two full crossbars-->
        <!--
       <complete name="first_half" input="dsp_top.dsp_I1" output="dsp.dsp_I1">
            <delay_constant max="333e-12" in_port="dsp_top.dsp_I1" out_port="dsp.dsp_I1"/>
       </complete>

        <complete name="second_half" input="dsp_top.dsp_I2" output="dsp.dsp_I2">
            <delay_constant max="333e-12" in_port="dsp_top.dsp_I2" out_port="dsp.dsp_I2"/>
        </complete>
        -->
        <direct name="enable" input="dsp_top.dsp_I1[0]" output ="dsp.dsp_I1[0]"/>
        <direct name="loadconst" input="dsp_top.dsp_I1[1]" output ="dsp.dsp_I1[1]"/>
        <direct name="accumulate" input="dsp_top.dsp_I1[2]" output ="dsp.dsp_I1[2]"/>
        <direct name="negate" input="dsp_top.dsp_I1[3]" output ="dsp.dsp_I1[3]"/>
        <direct name="sub" input="dsp_top.dsp_I1[4]" output ="dsp.dsp_I1[4]"/>
        <direct name="mode" input="dsp_top.dsp_I1[7:5]" output ="dsp.dsp_I1[7:5]"/>
        <direct name="mux9_select" input="dsp_top.dsp_I1[8]" output ="dsp.dsp_I1[8]"/>
        <direct name="internal_coeffa" input="dsp_top.dsp_I1[9]" output ="dsp.dsp_I1[9]"/>
        <direct name="internal_coeffb" input="dsp_top.dsp_I1[10]" output ="dsp.dsp_I1[10]"/>
        <direct name="datain1" input="dsp_top.dsp_I1[63:11]" output ="dsp.dsp_I1[63:11]"/>
        <direct name="datain2" input="dsp_top.dsp_I2" output ="dsp.dsp_I2"/>
 
        <direct name="reset" input="dsp_top.reset" output="dsp.reset"></direct>
        <direct name="chainin" input="dsp_top.chainin" output="dsp.chainin">
            <delay_constant max="1179e-12" in_port="dsp_top.chainin" out_port="dsp.chainin"/>
        </direct>
        <direct name="chainout" input="dsp.chainout" output="dsp_top.chainout">
            <delay_constant max="1179e-12" in_port="dsp.chainout" out_port="dsp_top.chainout"/>
        </direct>
        <direct name="scanin" input="dsp_top.scanin" output="dsp.scanin">
            <delay_constant max="1179e-12" in_port="dsp_top.scanin" out_port="dsp.scanin"/>
        </direct>
        <direct name="scanout" input="dsp.scanout" output="dsp_top.scanout">
            <delay_constant max="1179e-12" in_port="dsp.scanout" out_port="dsp_top.scanout"/>
        </direct>
        <direct name="result" input="dsp.result" output="dsp_top.result"></direct>
        <direct name="clk" input="dsp_top.clk" output="dsp.clk"></direct>
    </interconnect>
    </pb_type>
    <!-- Define DSP slice end -->

    <!-- Define fracturable memory begin -->
    <!-- 
    RAM blocks always have registered inputs. The input FFs appear before the address decoder & wordline driver,
    and after the local input crossbar & level shifter.
    RAM blocks optionally have registered outputs. The output FFs (if present) appear after the output crossbar.
    If BRAM doesn't have registered outputs, then T_clk_to_q is the whole delay of the read/write operation.
    If BRAM does have registered output, then T_clk_to_q is just the FF clk_to_q and then delay_constant
    can be used to specify the whole delay of the read/write operation.

    This RAM block has registered outputs.

    The area and delay values of this RAM block were obtained (indirectly) from COFFE simulations.
    COFFE only support widths and depths that are powers of 2. For M20K (20 Kilobit BRAM), we need
    the width to be 40 bits and depth to be 512 (for the logically widest mode: 512x40). We can't
    simulate these dimensions directly in COFFE. So, we simulated and obtained the results for M32K
    (32 Kilobits BRAM) and (16 Kilobits BRAM). Then we interpolated the results.
    For delay, a linear interpolation was used, based on the size of the Memory (16K->20K->32K).
    For area, the value was calculated using two interpolations: (1) port based (change in number of 
    ports in going from 16K->20K->32K) and (2) number of bits based (change in number of bits in
    going from 16K->20K->32K). The interpolation that resulted in the larger area was picked.
    

    Here are the equations used to calculate the delays based on COFFE results:
    T_setup (inputs) = T_level_shifter + T_register_micro_setup = 32.3ps + 18.91ps = 51.21ps
    T_clk_to_q (inputs) = T_register_micro_clk_to_q = 60.32ps
    T_setup (outputs) = T_register_micro_setup = 18.91ps 
    T_clk_to_q (outputs) = T_register_micro_clk_to_q = 60.32ps

    (Register setup and clk_to_q timings are actually from the FF used in the logic cluster.)

    T_read = T1 + T2 + T3
    = max (Row decoder, Pre-charge time) + (Wordline driver + Bit line delay) + (Sense amp + Output crossbar)

    * Bit line delay is included in self.RAM.samp.delay time in COFFE. The Sense amp delay is actually
    self.RAM.samp_part2.delay

    T_write = T1 + T2 + T3
    = max (Row decoder, Pre-charge time) + (Wordline driver) + (Write driver)

    delay_constant values model the internal limits of a block (the combinatorial delay).
    delay_constant = max (T_read, T_write) 

	  Overall internal delay of the RAM is T_clk_to_q (inputs) + delay_constant + T_setup (outputs)
    -->
    <pb_type name="memory">
      <input name="addr1" num_pins="11"/>
      <input name="addr2" num_pins="11"/>
      <input name="data" num_pins="40"/>
      <input name="we1" num_pins="1"/>
      <input name="we2" num_pins="1"/>
      <output name="out" num_pins="40"/>
      <clock name="clk" num_pins="1"/>
      <!-- Specify single port mode first -->
      <mode name="mem_512x40_sp">
        <pb_type name="mem_512x40_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="9" port_class="address"/>
          <input name="data" num_pins="40" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="40" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="66e-12" port="mem_512x40_sp.addr" clock="clk"/>
          <T_setup value="66e-12" port="mem_512x40_sp.data" clock="clk"/>
          <T_setup value="66e-12" port="mem_512x40_sp.we" clock="clk"/>
          <T_setup value="66e-12" port="mem_512x40_sp.out" clock="clk"/>

          <T_clock_to_Q max="124e-12" port="mem_512x40_sp.addr" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_512x40_sp.data" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_512x40_sp.we" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_512x40_sp.out" clock="clk"/>

          <delay_constant max="1.1374e-9" in_port="mem_512x40_sp.addr" out_port="mem_512x40_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_512x40_sp.data" out_port="mem_512x40_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_512x40_sp.we"   out_port="mem_512x40_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[8:0]" output="mem_512x40_sp.addr">
          </direct>
          <direct name="data1" input="memory.data" output="mem_512x40_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_512x40_sp.we">
          </direct>
          <direct name="dataout1" input="mem_512x40_sp.out" output="memory.out">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_512x40_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_1024x20_sp">
        <pb_type name="mem_1024x20_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="10" port_class="address"/>
          <input name="data" num_pins="20" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="20" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="66e-12" port="mem_1024x20_sp.addr" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_sp.data" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_sp.we" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_sp.out" clock="clk"/>

          <T_clock_to_Q max="124e-12" port="mem_1024x20_sp.addr" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_sp.data" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_sp.we" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_sp.out" clock="clk"/>

          <delay_constant max="1.1374e-9" in_port="mem_1024x20_sp.addr" out_port="mem_1024x20_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_sp.data" out_port="mem_1024x20_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_sp.we"   out_port="mem_1024x20_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x20_sp.addr">
          </direct>
          <direct name="data1" input="memory.data[19:0]" output="mem_1024x20_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_1024x20_sp.we">
          </direct>
          <direct name="dataout1" input="mem_1024x20_sp.out" output="memory.out[19:0]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_1024x20_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_2048x10_sp">
        <pb_type name="mem_2048x10_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="11" port_class="address"/>
          <input name="data" num_pins="10" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="10" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="66e-12" port="mem_2048x10_sp.addr" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_sp.data" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_sp.we" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_sp.out" clock="clk"/>

          <T_clock_to_Q max="124e-12" port="mem_2048x10_sp.addr" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_sp.data" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_sp.we" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_sp.out" clock="clk"/>

          <delay_constant max="1.1374e-9" in_port="mem_2048x10_sp.addr" out_port="mem_2048x10_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_sp.data" out_port="mem_2048x10_sp.out"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_sp.we"   out_port="mem_2048x10_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x10_sp.addr">
          </direct>
          <direct name="data1" input="memory.data[9:0]" output="mem_2048x10_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_2048x10_sp.we">
          </direct>
          <direct name="dataout1" input="mem_2048x10_sp.out" output="memory.out[9:0]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_2048x10_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <!-- Specify true dual port mode next -->
      <mode name="mem_1024x20_dp">
        <pb_type name="mem_1024x20_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
          <input name="addr1" num_pins="10" port_class="address1"/>
          <input name="addr2" num_pins="10" port_class="address2"/>
          <input name="data1" num_pins="20" port_class="data_in1"/>
          <input name="data2" num_pins="20" port_class="data_in2"/>
          <input name="we1" num_pins="1" port_class="write_en1"/>
          <input name="we2" num_pins="1" port_class="write_en2"/>
          <output name="out1" num_pins="20" port_class="data_out1"/>
          <output name="out2" num_pins="20" port_class="data_out2"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="66e-12" port="mem_1024x20_dp.addr1" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.data1" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.we1" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.addr2" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.data2" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.we2" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.out1" clock="clk"/>
          <T_setup value="66e-12" port="mem_1024x20_dp.out2" clock="clk"/>

          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.addr1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.data1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.we1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.addr2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.data2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.we2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.out1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_1024x20_dp.out2" clock="clk"/>

          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.addr1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.data1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.we1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.addr2" out_port="mem_1024x20_dp.out2"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.data2" out_port="mem_1024x20_dp.out2"/>
          <delay_constant max="1.1374e-9" in_port="mem_1024x20_dp.we2" out_port="mem_1024x20_dp.out2"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x20_dp.addr1">
          </direct>
          <direct name="address2" input="memory.addr2[9:0]" output="mem_1024x20_dp.addr2">
          </direct>
          <direct name="data1" input="memory.data[19:0]" output="mem_1024x20_dp.data1">
          </direct>
          <direct name="data2" input="memory.data[39:20]" output="mem_1024x20_dp.data2">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_1024x20_dp.we1">
          </direct>
          <direct name="writeen2" input="memory.we2" output="mem_1024x20_dp.we2">
          </direct>
          <direct name="dataout1" input="mem_1024x20_dp.out1" output="memory.out[19:0]">
          </direct>
          <direct name="dataout2" input="mem_1024x20_dp.out2" output="memory.out[39:20]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_1024x20_dp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_2048x10_dp">
        <pb_type name="mem_2048x10_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
          <input name="addr1" num_pins="11" port_class="address1"/>
          <input name="addr2" num_pins="11" port_class="address2"/>
          <input name="data1" num_pins="10" port_class="data_in1"/>
          <input name="data2" num_pins="10" port_class="data_in2"/>
          <input name="we1" num_pins="1" port_class="write_en1"/>
          <input name="we2" num_pins="1" port_class="write_en2"/>
          <output name="out1" num_pins="10" port_class="data_out1"/>
          <output name="out2" num_pins="10" port_class="data_out2"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="66e-12" port="mem_2048x10_dp.addr1" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.data1" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.we1" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.addr2" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.data2" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.we2" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.out1" clock="clk"/>
          <T_setup value="66e-12" port="mem_2048x10_dp.out2" clock="clk"/>

          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.addr1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.data1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.we1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.addr2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.data2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.we2" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.out1" clock="clk"/>
          <T_clock_to_Q max="124e-12" port="mem_2048x10_dp.out2" clock="clk"/>

          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.addr1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.data1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.we1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.addr2" out_port="mem_2048x10_dp.out2"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.data2" out_port="mem_2048x10_dp.out2"/>
          <delay_constant max="1.1374e-9" in_port="mem_2048x10_dp.we2" out_port="mem_2048x10_dp.out2"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x10_dp.addr1">
          </direct>
          <direct name="address2" input="memory.addr2[10:0]" output="mem_2048x10_dp.addr2">
          </direct>
          <direct name="data1" input="memory.data[9:0]" output="mem_2048x10_dp.data1">
          </direct>
          <direct name="data2" input="memory.data[19:10]" output="mem_2048x10_dp.data2">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_2048x10_dp.we1">
          </direct>
          <direct name="writeen2" input="memory.we2" output="mem_2048x10_dp.we2">
          </direct>
          <direct name="dataout1" input="mem_2048x10_dp.out1" output="memory.out[9:0]">
          </direct>
          <direct name="dataout2" input="mem_2048x10_dp.out2" output="memory.out[19:10]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_2048x10_dp.clk">
          </direct>
        </interconnect>
      </mode>
    </pb_type>
    <!-- Define fracturable memory end -->

    <pb_type name="axi_hbm_tile">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1" is_non_clock_global="true"/>

      <output name="hbm_outpad" num_pins="128"/>
      <input name="hbm_inpad" num_pins="128"/>
      
      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

      <mode name="physical" disable_packing="true">
         <pb_type name="axi_hbm_physical" blif_model=".subckt axi_hbm_physical" num_pb="1">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1"/>
      
      <output name="hbm_outpad" num_pins="128"/>
      <input name="hbm_inpad" num_pins="128"/>

      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="axi_hbm_physical.rst" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.rst" clock="clk"/>

            <T_setup value="66e-12" port="axi_hbm_physical.hbm_inpad" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.hbm_inpad" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tdest" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tready" clock="clk"/>

            <T_setup value="66e-12" port="axi_hbm_physical.hbm_outpad" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.hbm_outpad" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_in_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_in_tready" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm_physical.axis_out_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm_physical.axis_out_tdest" clock="clk"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.rst" out_port="axi_hbm_physical.axis_out_tdest"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.hbm_inpad" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tvalid" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdata" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tlast" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tid" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_in_tdest" out_port="axi_hbm_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm_physical.axis_out_tready" out_port="axi_hbm_physical.axis_out_tdest"/>
            </pb_type>
         <interconnect>
            <direct name="hbm_wire_clk" input="axi_hbm_tile.clk" output="axi_hbm_physical.clk"/>
            <direct name="hbm_wire_rst" input="axi_hbm_tile.rst" output="axi_hbm_physical.rst"/>
            
            <direct name="hbm_wire_hbm_inpad" input="axi_hbm_tile.hbm_inpad" output="axi_hbm_physical.hbm_inpad"/>
            <direct name="hbm_wire_axis_in_tvalid" input="axi_hbm_tile.axis_in_tvalid" output="axi_hbm_physical.axis_in_tvalid"/>
            <direct name="hbm_wire_axis_in_tdata" input="axi_hbm_tile.axis_in_tdata" output="axi_hbm_physical.axis_in_tdata"/>
            <direct name="hbm_wire_axis_in_tlast" input="axi_hbm_tile.axis_in_tlast" output="axi_hbm_physical.axis_in_tlast"/>
            <direct name="hbm_wire_axis_in_tid" input="axi_hbm_tile.axis_in_tid" output="axi_hbm_physical.axis_in_tid"/>
            <direct name="hbm_wire_axis_in_tdest" input="axi_hbm_tile.axis_in_tdest" output="axi_hbm_physical.axis_in_tdest"/>
            <direct name="hbm_wire_axis_out_tready" input="axi_hbm_tile.axis_out_tready" output="axi_hbm_physical.axis_out_tready"/>

            <direct name="hbm_wire_hbm_outpad" input="axi_hbm_physical.hbm_outpad" output="axi_hbm_tile.hbm_outpad"/>
            <direct name="hbm_wire_axis_in_tready" input="axi_hbm_physical.axis_in_tready" output="axi_hbm_tile.axis_in_tready"/>
            <direct name="hbm_wire_axis_out_tvalid" input="axi_hbm_physical.axis_out_tvalid" output="axi_hbm_tile.axis_out_tvalid"/>
            <direct name="hbm_wire_axis_out_tdata" input="axi_hbm_physical.axis_out_tdata" output="axi_hbm_tile.axis_out_tdata"/>
            <direct name="hbm_wire_axis_out_tlast" input="axi_hbm_physical.axis_out_tlast" output="axi_hbm_tile.axis_out_tlast"/>
            <direct name="hbm_wire_axis_out_tid" input="axi_hbm_physical.axis_out_tid" output="axi_hbm_tile.axis_out_tid"/>
            <direct name="hbm_wire_axis_out_tdest" input="axi_hbm_physical.axis_out_tdest" output="axi_hbm_tile.axis_out_tdest"/>
            </interconnect>
      </mode>
      <mode name="axi_hbm">
         <pb_type name="axi_hbm" blif_model=".subckt axi_hbm" num_pb="1">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1"/>

      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="axi_hbm.rst" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.rst" clock="clk"/>

            <T_setup value="66e-12" port="axi_hbm.axis_in_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_in_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_in_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_in_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_in_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tdest" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tready" clock="clk"/>

            <T_setup value="66e-12" port="axi_hbm.axis_in_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_in_tready" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_hbm.axis_out_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_hbm.axis_out_tdest" clock="clk"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.rst" out_port="axi_hbm.axis_out_tdest"/>

            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tvalid" out_port="axi_hbm.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdata" out_port="axi_hbm.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tlast" out_port="axi_hbm.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tid" out_port="axi_hbm.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_in_tdest" out_port="axi_hbm.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_hbm.axis_out_tready" out_port="axi_hbm.axis_out_tdest"/>
            </pb_type>
         <interconnect>
            <direct name="hbm_wire_clk" input="axi_hbm_tile.clk" output="axi_hbm.clk"/>
            <direct name="hbm_wire_rst" input="axi_hbm_tile.rst" output="axi_hbm.rst"/>
            
            <direct name="hbm_wire_axis_in_tvalid" input="axi_hbm_tile.axis_in_tvalid" output="axi_hbm.axis_in_tvalid"/>
            <direct name="hbm_wire_axis_in_tdata" input="axi_hbm_tile.axis_in_tdata" output="axi_hbm.axis_in_tdata"/>
            <direct name="hbm_wire_axis_in_tlast" input="axi_hbm_tile.axis_in_tlast" output="axi_hbm.axis_in_tlast"/>
            <direct name="hbm_wire_axis_in_tid" input="axi_hbm_tile.axis_in_tid" output="axi_hbm.axis_in_tid"/>
            <direct name="hbm_wire_axis_in_tdest" input="axi_hbm_tile.axis_in_tdest" output="axi_hbm.axis_in_tdest"/>
            <direct name="hbm_wire_axis_out_tready" input="axi_hbm_tile.axis_out_tready" output="axi_hbm.axis_out_tready"/>

            <direct name="hbm_wire_axis_in_tready" input="axi_hbm.axis_in_tready" output="axi_hbm_tile.axis_in_tready"/>
            <direct name="hbm_wire_axis_out_tvalid" input="axi_hbm.axis_out_tvalid" output="axi_hbm_tile.axis_out_tvalid"/>
            <direct name="hbm_wire_axis_out_tdata" input="axi_hbm.axis_out_tdata" output="axi_hbm_tile.axis_out_tdata"/>
            <direct name="hbm_wire_axis_out_tlast" input="axi_hbm.axis_out_tlast" output="axi_hbm_tile.axis_out_tlast"/>
            <direct name="hbm_wire_axis_out_tid" input="axi_hbm.axis_out_tid" output="axi_hbm_tile.axis_out_tid"/>
            <direct name="hbm_wire_axis_out_tdest" input="axi_hbm.axis_out_tdest" output="axi_hbm_tile.axis_out_tdest"/>
            </interconnect>
         </mode>
    </pb_type>
    <pb_type name="axi_eth_tile">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1" is_non_clock_global="true"/>

      <output name="eth_outpad" num_pins="128"/>
      <input name="eth_inpad" num_pins="128"/>
      
      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

      <mode name="physical" disable_packing="true">
         <pb_type name="axi_eth_physical" blif_model=".subckt axi_eth_physical" num_pb="1">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1"/>
      
      <output name="eth_outpad" num_pins="128"/>
      <input name="eth_inpad" num_pins="128"/>

      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="axi_eth_physical.rst" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.rst" clock="clk"/>

            <T_setup value="66e-12" port="axi_eth_physical.eth_inpad" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.eth_inpad" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tdest" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tready" clock="clk"/>

            <T_setup value="66e-12" port="axi_eth_physical.eth_outpad" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.eth_outpad" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_in_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_in_tready" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth_physical.axis_out_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth_physical.axis_out_tdest" clock="clk"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.rst" out_port="axi_eth_physical.axis_out_tdest"/>

            <delay_constant max="1.788e-9" in_port="axi_eth_physical.eth_inpad" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tvalid" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdata" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tlast" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tid" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_in_tdest" out_port="axi_eth_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth_physical.axis_out_tready" out_port="axi_eth_physical.axis_out_tdest"/>
            </pb_type>
         <interconnect>
            <direct name="eth_wire_clk" input="axi_eth_tile.clk" output="axi_eth_physical.clk"/>
            <direct name="eth_wire_rst" input="axi_eth_tile.rst" output="axi_eth_physical.rst"/>
            
            <direct name="eth_wire_eth_inpad" input="axi_eth_tile.eth_inpad" output="axi_eth_physical.eth_inpad"/>
            <direct name="eth_wire_axis_in_tvalid" input="axi_eth_tile.axis_in_tvalid" output="axi_eth_physical.axis_in_tvalid"/>
            <direct name="eth_wire_axis_in_tdata" input="axi_eth_tile.axis_in_tdata" output="axi_eth_physical.axis_in_tdata"/>
            <direct name="eth_wire_axis_in_tlast" input="axi_eth_tile.axis_in_tlast" output="axi_eth_physical.axis_in_tlast"/>
            <direct name="eth_wire_axis_in_tid" input="axi_eth_tile.axis_in_tid" output="axi_eth_physical.axis_in_tid"/>
            <direct name="eth_wire_axis_in_tdest" input="axi_eth_tile.axis_in_tdest" output="axi_eth_physical.axis_in_tdest"/>
            <direct name="eth_wire_axis_out_tready" input="axi_eth_tile.axis_out_tready" output="axi_eth_physical.axis_out_tready"/>

            <direct name="eth_wire_eth_outpad" input="axi_eth_physical.eth_outpad" output="axi_eth_tile.eth_outpad"/>
            <direct name="eth_wire_axis_in_tready" input="axi_eth_physical.axis_in_tready" output="axi_eth_tile.axis_in_tready"/>
            <direct name="eth_wire_axis_out_tvalid" input="axi_eth_physical.axis_out_tvalid" output="axi_eth_tile.axis_out_tvalid"/>
            <direct name="eth_wire_axis_out_tdata" input="axi_eth_physical.axis_out_tdata" output="axi_eth_tile.axis_out_tdata"/>
            <direct name="eth_wire_axis_out_tlast" input="axi_eth_physical.axis_out_tlast" output="axi_eth_tile.axis_out_tlast"/>
            <direct name="eth_wire_axis_out_tid" input="axi_eth_physical.axis_out_tid" output="axi_eth_tile.axis_out_tid"/>
            <direct name="eth_wire_axis_out_tdest" input="axi_eth_physical.axis_out_tdest" output="axi_eth_tile.axis_out_tdest"/>
            </interconnect>
      </mode>
      <mode name="axi_eth">
         <pb_type name="axi_eth" blif_model=".subckt axi_eth" num_pb="1">
      <clock name="clk" num_pins="1"/>
      <input name="rst" num_pins="1"/>

      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="axi_eth.rst" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.rst" clock="clk"/>

            <T_setup value="66e-12" port="axi_eth.axis_in_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_in_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_in_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_in_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_in_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tdest" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tready" clock="clk"/>

            <T_setup value="66e-12" port="axi_eth.axis_in_tready" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_in_tready" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tvalid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tvalid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tdata" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tdata" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tlast" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tlast" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tid" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tid" clock="clk"/>
            <T_setup value="66e-12" port="axi_eth.axis_out_tdest" clock="clk"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="axi_eth.axis_out_tdest" clock="clk"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.rst" out_port="axi_eth.axis_out_tdest"/>

            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tvalid" out_port="axi_eth.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdata" out_port="axi_eth.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tlast" out_port="axi_eth.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tid" out_port="axi_eth.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_in_tdest" out_port="axi_eth.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="axi_eth.axis_out_tready" out_port="axi_eth.axis_out_tdest"/>
            </pb_type>
         <interconnect>
            <direct name="eth_wire_clk" input="axi_eth_tile.clk" output="axi_eth.clk"/>
            <direct name="eth_wire_rst" input="axi_eth_tile.rst" output="axi_eth.rst"/>
            
            <direct name="eth_wire_axis_in_tvalid" input="axi_eth_tile.axis_in_tvalid" output="axi_eth.axis_in_tvalid"/>
            <direct name="eth_wire_axis_in_tdata" input="axi_eth_tile.axis_in_tdata" output="axi_eth.axis_in_tdata"/>
            <direct name="eth_wire_axis_in_tlast" input="axi_eth_tile.axis_in_tlast" output="axi_eth.axis_in_tlast"/>
            <direct name="eth_wire_axis_in_tid" input="axi_eth_tile.axis_in_tid" output="axi_eth.axis_in_tid"/>
            <direct name="eth_wire_axis_in_tdest" input="axi_eth_tile.axis_in_tdest" output="axi_eth.axis_in_tdest"/>
            <direct name="eth_wire_axis_out_tready" input="axi_eth_tile.axis_out_tready" output="axi_eth.axis_out_tready"/>

            <direct name="eth_wire_axis_in_tready" input="axi_eth.axis_in_tready" output="axi_eth_tile.axis_in_tready"/>
            <direct name="eth_wire_axis_out_tvalid" input="axi_eth.axis_out_tvalid" output="axi_eth_tile.axis_out_tvalid"/>
            <direct name="eth_wire_axis_out_tdata" input="axi_eth.axis_out_tdata" output="axi_eth_tile.axis_out_tdata"/>
            <direct name="eth_wire_axis_out_tlast" input="axi_eth.axis_out_tlast" output="axi_eth_tile.axis_out_tlast"/>
            <direct name="eth_wire_axis_out_tid" input="axi_eth.axis_out_tid" output="axi_eth_tile.axis_out_tid"/>
            <direct name="eth_wire_axis_out_tdest" input="axi_eth.axis_out_tdest" output="axi_eth_tile.axis_out_tdest"/>
            </interconnect>
         </mode>
    </pb_type>

    <pb_type name="router_wrap_tile">
      <input name="clk_noc" num_pins="1" is_non_clock_global="true"/>
      <clock name="clk_usr" num_pins="1"/>
      <input name="rst_n" num_pins="1" is_non_clock_global="true"/>

      <input name="data_in" num_pins="256"/>
      <input name="dest_in" num_pins="16"/>
      <input name="is_tail_in" num_pins="4"/>
      <input name="send_in" num_pins="4"/>
      <input name="credit_in" num_pins="4"/>

      <output name="credit_out" num_pins="4"/>
      <output name="data_out" num_pins="256"/>
      <output name="dest_out" num_pins="16"/>
      <output name="is_tail_out" num_pins="4"/>
      <output name="send_out" num_pins="4"/>

      <!-- <input name="DISABLE_TURNS" num_pins="25"/> -->
      <input name="router_address" num_pins="4"/>
      
      <input name="axis_in_tvalid" num_pins="1"/>
      <input name="axis_in_tdata" num_pins="128"/>
      <input name="axis_in_tlast" num_pins="1"/>
      <input name="axis_in_tid" num_pins="2"/>
      <input name="axis_in_tdest" num_pins="4"/>
      <input name="axis_out_tready" num_pins="1"/>
                  
      <output name="axis_in_tready" num_pins="1"/>
      <output name="axis_out_tvalid" num_pins="1"/>
      <output name="axis_out_tdata" num_pins="128"/>
      <output name="axis_out_tlast" num_pins="1"/>
      <output name="axis_out_tid" num_pins="2"/>
      <output name="axis_out_tdest" num_pins="4"/>
        <mode name="physical">
          <pb_type name="router_wrap_physical" blif_model=".subckt router_wrap_physical" num_pb="1">
            <input name="clk_noc" num_pins="1"/>
            <clock name="clk_usr" num_pins="1"/>
            <input name="rst_n" num_pins="1"/>

            <input name="data_in" num_pins="256"/>
            <input name="dest_in" num_pins="16"/>
            <input name="is_tail_in" num_pins="4"/>
            <input name="send_in" num_pins="4"/>
            <input name="credit_in" num_pins="4"/>

            <output name="credit_out" num_pins="4"/>
            <output name="data_out" num_pins="256"/>
            <output name="dest_out" num_pins="16"/>
            <output name="is_tail_out" num_pins="4"/>
            <output name="send_out" num_pins="4"/>

            <!-- <input name="DISABLE_TURNS" num_pins="25"/> -->
            <input name="router_address" num_pins="4"/>

            <input name="axis_in_tvalid" num_pins="1"/>
            <input name="axis_in_tdata" num_pins="128"/>
            <input name="axis_in_tlast" num_pins="1"/>
            <input name="axis_in_tid" num_pins="2"/>
            <input name="axis_in_tdest" num_pins="4"/>
            <input name="axis_out_tready" num_pins="1"/>

            <output name="axis_in_tready" num_pins="1"/>
            <output name="axis_out_tvalid" num_pins="1"/>
            <output name="axis_out_tdata" num_pins="128"/>
            <output name="axis_out_tlast" num_pins="1"/>
            <output name="axis_out_tid" num_pins="2"/>
            <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="router_wrap_physical.clk_noc" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.clk_noc" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.rst_n" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.rst_n" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.data_in" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.data_in" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.dest_in" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.dest_in" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.is_tail_in" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.is_tail_in" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.send_in" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.send_in" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.credit_in" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.credit_in" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tvalid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tvalid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tdata" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tdata" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tlast" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tlast" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tdest" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tdest" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tready" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tready" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.router_address" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.router_address" clock="clk_usr"/>

            <T_setup value="66e-12" port="router_wrap_physical.credit_out" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.credit_out" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.data_out" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.data_out" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.dest_out" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.dest_out" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.is_tail_out" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.is_tail_out" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.send_out" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.send_out" clock="clk_usr"/>
            
            <T_setup value="66e-12" port="router_wrap_physical.axis_in_tready" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_in_tready" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tvalid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tvalid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tdata" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tdata" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tlast" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tlast" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap_physical.axis_out_tdest" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap_physical.axis_out_tdest" clock="clk_usr"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="router_wrap_physical.clk_noc" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.rst_n" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.data_in" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.dest_in" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.is_tail_in" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.send_in" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.credit_in" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tvalid" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdata" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tlast" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tid" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_in_tdest" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.axis_out_tready" out_port="router_wrap_physical.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap_physical.router_address" out_port="router_wrap_physical.axis_out_tdest"/>
          </pb_type>
          <interconnect>
            <direct name="phy_connection_clk_noc" input="router_wrap_tile.clk_noc" output="router_wrap_physical.clk_noc"/>
            <direct name="phy_connection_clk_usr" input="router_wrap_tile.clk_usr" output="router_wrap_physical.clk_usr"/>
            <direct name="phy_connection_rst_n" input="router_wrap_tile.rst_n" output="router_wrap_physical.rst_n"/>
            <direct name="phy_connection_data_in" input="router_wrap_tile.data_in" output="router_wrap_physical.data_in"/>
            <direct name="phy_connection_dest_in" input="router_wrap_tile.dest_in" output="router_wrap_physical.dest_in"/>
            <direct name="phy_connection_is_tail_in" input="router_wrap_tile.is_tail_in" output="router_wrap_physical.is_tail_in"/>
            <direct name="phy_connection_send_in" input="router_wrap_tile.send_in" output="router_wrap_physical.send_in"/>
            <direct name="phy_connection_credit_in" input="router_wrap_tile.credit_in" output="router_wrap_physical.credit_in"/>
            <!-- <direct name="phy_connection_DISABLE_TURNS" input="router_wrap_tile.DISABLE_TURNS" output="router_wrap_physical.DISABLE_TURNS"/> -->
            <direct name="phy_connection_axis_in_tvalid" input="router_wrap_tile.axis_in_tvalid" output="router_wrap_physical.axis_in_tvalid"/>
            <direct name="phy_connection_axis_in_tdata" input="router_wrap_tile.axis_in_tdata" output="router_wrap_physical.axis_in_tdata"/>
            <direct name="phy_connection_axis_in_tlast" input="router_wrap_tile.axis_in_tlast" output="router_wrap_physical.axis_in_tlast"/>
            <direct name="phy_connection_axis_in_tid" input="router_wrap_tile.axis_in_tid" output="router_wrap_physical.axis_in_tid"/>
            <direct name="phy_connection_axis_in_tdest" input="router_wrap_tile.axis_in_tdest" output="router_wrap_physical.axis_in_tdest"/>
            <direct name="phy_connection_axis_out_tready" input="router_wrap_tile.axis_out_tready" output="router_wrap_physical.axis_out_tready"/>
            <direct name="phy_connection_router_address" input="router_wrap_tile.router_address" output="router_wrap_physical.router_address"/>
            <direct name="phy_connection_credit_out" input="router_wrap_physical.credit_out" output="router_wrap_tile.credit_out"/>
            <direct name="phy_connection_data_out" input="router_wrap_physical.data_out" output="router_wrap_tile.data_out"/>
            <direct name="phy_connection_dest_out" input="router_wrap_physical.dest_out" output="router_wrap_tile.dest_out"/>
            <direct name="phy_connection_is_tail_out" input="router_wrap_physical.is_tail_out" output="router_wrap_tile.is_tail_out"/>
            <direct name="phy_connection_send_out" input="router_wrap_physical.send_out" output="router_wrap_tile.send_out"/>
            <direct name="phy_connection_axis_in_tready" input="router_wrap_physical.axis_in_tready" output="router_wrap_tile.axis_in_tready"/>
            <direct name="phy_connection_axis_out_tvalid" input="router_wrap_physical.axis_out_tvalid" output="router_wrap_tile.axis_out_tvalid"/>
            <direct name="phy_connection_axis_out_tdata" input="router_wrap_physical.axis_out_tdata" output="router_wrap_tile.axis_out_tdata"/>
            <direct name="phy_connection_axis_out_tlast" input="router_wrap_physical.axis_out_tlast" output="router_wrap_tile.axis_out_tlast"/>
            <direct name="phy_connection_axis_out_tid" input="router_wrap_physical.axis_out_tid" output="router_wrap_tile.axis_out_tid"/>
            <direct name="phy_connection_axis_out_tdest" input="router_wrap_physical.axis_out_tdest" output="router_wrap_tile.axis_out_tdest"/>
          </interconnect>
        </mode>
        <mode name="router_wrap">
          <pb_type name="router_wrap" blif_model=".subckt router_wrap" num_pb="1">
            <input name="clk_noc" num_pins="1"/>
            <clock name="clk_usr" num_pins="1"/>
            <input name="rst_n" num_pins="1"/>

            <input name="router_address" num_pins="4"/>

            <input name="axis_in_tvalid" num_pins="1"/>
            <input name="axis_in_tdata" num_pins="128"/>
            <input name="axis_in_tlast" num_pins="1"/>
            <input name="axis_in_tid" num_pins="2"/>
            <input name="axis_in_tdest" num_pins="4"/>
            <input name="axis_out_tready" num_pins="1"/>

            <output name="axis_in_tready" num_pins="1"/>
            <output name="axis_out_tvalid" num_pins="1"/>
            <output name="axis_out_tdata" num_pins="128"/>
            <output name="axis_out_tlast" num_pins="1"/>
            <output name="axis_out_tid" num_pins="2"/>
            <output name="axis_out_tdest" num_pins="4"/>

            <T_setup value="66e-12" port="router_wrap.clk_noc" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.clk_noc" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.rst_n" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.rst_n" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_in_tvalid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tvalid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_in_tdata" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tdata" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_in_tlast" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tlast" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_in_tid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_in_tdest" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tdest" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tready" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tready" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.router_address" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.router_address" clock="clk_usr"/>

            <T_setup value="66e-12" port="router_wrap.axis_in_tready" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_in_tready" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tvalid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tvalid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tdata" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tdata" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tlast" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tlast" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tid" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tid" clock="clk_usr"/>
            <T_setup value="66e-12" port="router_wrap.axis_out_tdest" clock="clk_usr"/>
            <T_clock_to_Q max="42e-12" min="37e-12" port="router_wrap.axis_out_tdest" clock="clk_usr"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_out_tdata"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_out_tdata"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_in_tready"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_in_tready"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_out_tvalid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_out_tvalid"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_out_tlast"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_out_tlast"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_out_tid"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_out_tid"/>

            <delay_constant max="1.788e-9" in_port="router_wrap.clk_noc" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.rst_n" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tvalid" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdata" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tlast" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tid" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_in_tdest" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.axis_out_tready" out_port="router_wrap.axis_out_tdest"/>
            <delay_constant max="1.788e-9" in_port="router_wrap.router_address" out_port="router_wrap.axis_out_tdest"/>
          </pb_type>
          <interconnect>
            <direct name="connection_clk_noc" input="router_wrap_tile.clk_noc" output="router_wrap.clk_noc"/>
            <direct name="connection_clk_usr" input="router_wrap_tile.clk_usr" output="router_wrap.clk_usr"/>
            <direct name="connection_rst_n" input="router_wrap_tile.rst_n" output="router_wrap.rst_n"/>
            <direct name="connection_axis_in_tvalid" input="router_wrap_tile.axis_in_tvalid" output="router_wrap.axis_in_tvalid"/>
            <direct name="connection_axis_in_tdata" input="router_wrap_tile.axis_in_tdata" output="router_wrap.axis_in_tdata"/>
            <direct name="connection_axis_in_tlast" input="router_wrap_tile.axis_in_tlast" output="router_wrap.axis_in_tlast"/>
            <direct name="connection_axis_in_tid" input="router_wrap_tile.axis_in_tid" output="router_wrap.axis_in_tid"/>
            <direct name="connection_axis_in_tdest" input="router_wrap_tile.axis_in_tdest" output="router_wrap.axis_in_tdest"/>
            <direct name="connection_axis_out_tready" input="router_wrap_tile.axis_out_tready" output="router_wrap.axis_out_tready"/>
            <direct name="connection_router_address" input="router_wrap_tile.router_address" output="router_wrap.router_address"/>
            <direct name="connection_axis_in_tready" input="router_wrap.axis_in_tready" output="router_wrap_tile.axis_in_tready"/>
            <direct name="connection_axis_out_tvalid" input="router_wrap.axis_out_tvalid" output="router_wrap_tile.axis_out_tvalid"/>
            <direct name="connection_axis_out_tdata" input="router_wrap.axis_out_tdata" output="router_wrap_tile.axis_out_tdata"/>
            <direct name="connection_axis_out_tlast" input="router_wrap.axis_out_tlast" output="router_wrap_tile.axis_out_tlast"/>
            <direct name="connection_axis_out_tid" input="router_wrap.axis_out_tid" output="router_wrap_tile.axis_out_tid"/>
            <direct name="connection_axis_out_tdest" input="router_wrap.axis_out_tdest" output="router_wrap_tile.axis_out_tdest"/>
          </interconnect>
        </mode>
      </pb_type>
   </complexblocklist>


<noc link_latency="5" router_latency="7.7" link_bandwidth="10" noc_router_tile_name="router_wrap_tile">
<topology>

  <!-- Top Row (y = H/10 = 8) -->
  <router id="0"  positionx="8"  positiony="8"  connections="1 10"/>
  <router id="1"  positionx="16" positiony="8"  connections="0 2 11"/>
  <router id="2"  positionx="24" positiony="8"  connections="1 3 12"/>
  <router id="3"  positionx="32" positiony="8"  connections="2 4 13"/>
  <router id="4"  positionx="40" positiony="8"  connections="3 5 14"/>
  <router id="5"  positionx="48" positiony="8"  connections="4 6 15"/>
  <router id="6"  positionx="56" positiony="8"  connections="5 7 16"/>
  <router id="7"  positionx="64" positiony="8"  connections="6 8 17"/>
  <router id="8"  positionx="72" positiony="8"  connections="7 9 50"/>
  <router id="9"  positionx="80" positiony="8"  connections="8 51"/>

  <!-- Row 2 (y = 2·H/10 = 16) -->
  <router id="10" positionx="8"  positiony="16" connections="0 18"/>
  <router id="11" positionx="16" positiony="16" connections="1 19"/>
  <router id="12" positionx="24" positiony="16" connections="2 20"/>
  <router id="13" positionx="32" positiony="16" connections="3 21"/>
  <router id="14" positionx="40" positiony="16" connections="4 22"/>
  <router id="15" positionx="48" positiony="16" connections="5 23"/>
  <router id="16" positionx="56" positiony="16" connections="6 24"/>
  <router id="17" positionx="64" positiony="16" connections="7 25"/>

  <!-- Row 3 (y = 3·H/10 = 24) -->
  <router id="18" positionx="8"  positiony="24" connections="10"/>
  <router id="19" positionx="16" positiony="24" connections="11"/>
  <router id="20" positionx="24" positiony="24" connections="12"/>
  <router id="21" positionx="32" positiony="24" connections="13"/>
  <router id="22" positionx="40" positiony="24" connections="14"/>
  <router id="23" positionx="48" positiony="24" connections="15"/>
  <router id="24" positionx="56" positiony="24" connections="16"/>
  <router id="25" positionx="64" positiony="24" connections="17"/>

  <!-- Row 4 (y = 7·H/10 = 56) -->
  <router id="26" positionx="8"  positiony="56" connections="34"/>
  <router id="27" positionx="16" positiony="56" connections="35"/>
  <router id="28" positionx="24" positiony="56" connections="36"/>
  <router id="29" positionx="32" positiony="56" connections="37"/>
  <router id="30" positionx="40" positiony="56" connections="38"/>
  <router id="31" positionx="48" positiony="56" connections="39"/>
  <router id="32" positionx="56" positiony="56" connections="40"/>
  <router id="33" positionx="64" positiony="56" connections="41"/>

  <!-- Row 5 (y = 8·H/10 = 64) -->
  <router id="34" positionx="8"  positiony="64" connections="26 42"/>
  <router id="35" positionx="16" positiony="64" connections="27 43"/>
  <router id="36" positionx="24" positiony="64" connections="28 44"/>
  <router id="37" positionx="32" positiony="64" connections="29 45"/>
  <router id="38" positionx="40" positiony="64" connections="30 46"/>
  <router id="39" positionx="48" positiony="64" connections="31 47"/>
  <router id="40" positionx="56" positiony="64" connections="32 48"/>
  <router id="41" positionx="64" positiony="64" connections="33 49"/>

  <!-- Bottom Row (y = 9·H/10 = 72) -->
  <router id="42" positionx="8"  positiony="72" connections="34 43"/>
  <router id="43" positionx="16" positiony="72" connections="35 42 44"/>
  <router id="44" positionx="24" positiony="72" connections="36 43 45"/>
  <router id="45" positionx="32" positiony="72" connections="37 44 46"/>
  <router id="46" positionx="40" positiony="72" connections="38 45 47"/>
  <router id="47" positionx="48" positiony="72" connections="39 46 48"/>
  <router id="48" positionx="56" positiony="72" connections="40 47 49"/>
  <router id="49" positionx="64" positiony="72" connections="41 48 50"/>
  <router id="50" positionx="72" positiony="72" connections="49 8"/>
  <router id="51" positionx="80" positiony="72" connections="50 9"/>

</topology>


</noc>



</architecture>
